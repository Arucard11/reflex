---
description: 
globs: 
alwaysApply: true
---
Okay, here's the project plan revised to use plain JavaScript instead of TypeScript. The core architecture (Three.js for rendering, Rapier for physics, Socket.io for networking) remains the same, but the language specifics are adjusted.

Project Plan: 1v1 Multiplayer FPS Duel (Three.js + Rapier + Socket.io - Plain JavaScript)

Core Technologies:

Client-Side: Three.js (WebGL Rendering ONLY), Rapier (Client-Side Physics: Prediction & Collision), Socket.io-client (Networking), Vanilla JavaScript (Logic, DOM Manipulation, ES Modules)

Server-Side: Node.js, Socket.io (Networking), Rapier (Authoritative Server-Side Physics: Validation & Simulation), Plain JavaScript (Server Logic, ES Modules or CommonJS), Potentially Redis/MongoDB (State/Persistence)

Shared: JavaScript Modules (for common constants, utility functions, potentially map geometry data structures)

Phase 1: Foundation Setup

Objective: Create the core structure for rendering, authoritative physics, and networking using JavaScript.

Tasks:

Project Infrastructure:

Set up monorepo (e.g., using npm/yarn workspaces) for client/, server/, shared/ packages.

Configure project structure for clear module imports between packages (using relative paths or potentially bundler path aliases if using one).

Establish basic CI/CD pipeline (e.g., GitHub Actions) for linting (ESLint), testing, and potentially client-side bundling/minification.

Why: Ensures a consistent development environment and facilitates code sharing using standard JavaScript modules.

Core Rendering (Three.js):

Initialize Three.js Scene, PerspectiveCamera, and WebGLRenderer using JavaScript.

Append renderer's canvas to DOM using standard JavaScript DOM APIs.

Implement viewport resizing listeners (window.addEventListener('resize', ...)) using JavaScript.

Set up basic scene lighting and shadow mapping in Three.js.

Why: Provides the visual output. Three.js is strictly for rendering based on data from Rapier and game state.

Physics Engine Setup (Rapier):

Initialize identical Rapier World instances on both client (browser JS) and server (Node.js) using the appropriate Rapier JavaScript bindings.

Load Map Physics Geometry: Both client and server MUST load the exact same map geometry data (e.g., plain JS objects/arrays representing vertices/indices, or loading from a common format). On the server, create Rapier Collider shapes for authoritative boundaries. On the client, create identical shapes for prediction. This data could be defined in the shared/ directory.

Set up the physics simulation loop (world.step()) using JavaScript's setInterval or requestAnimationFrame (client) / setInterval (server).

Why: Rapier manages ALL physics. Server-side map geometry is critical for authoritative validation. Using plain JavaScript for Rapier interactions.

Network Foundation (Socket.io):

Set up Socket.io server and client instances using their standard JavaScript libraries.

Define basic message types (e.g., using string constants or simple objects defined in shared/). Create serialization/deserialization functions (JSON is standard; potentially explore binary options later if needed).

Implement a heartbeat/ping-pong mechanism.

Why: Establishes the real-time communication channel.

Phase 2: Player Systems

Objective: Implement player representation, physics-driven movement, and networked synchronization using JavaScript.

Tasks:

Avatar System (Three.js & JS Logic):

Load 3D character models (GLB/glTF) using Three.js GLTFLoader in JavaScript.

Implement animation playback (AnimationMixer) based on player state variables (e.g., isIdle, isRunning).

First-Person Camera Rig: Create the FPV setup using JavaScript. Attach animated character arms to the currently equipped weapon model (Three.js objects). Parent this combined arm-weapon mesh to the Three.js camera.

Create a third-person camera controller (optional).

Why: Provides player visual representation and the immersive FPV view using JavaScript logic to manage the scene graph.

Movement Engine (Vanilla JS, Rapier, Socket.io):

Capture keyboard/mouse input using standard browser event listeners (window.addEventListener, document.addEventListener).

Apply forces/impulses/velocity changes to the player's Rapier RigidBody or KinematicCharacterController using Rapier's JavaScript API.

Collision Detection: Handle collisions strictly within the Rapier physics world.

Visual Update: In the render loop (requestAnimationFrame), update the Three.js avatar and FPV rig's position/rotation to match the state read from the Rapier physics body's JavaScript object representation.

Why: Enables physics-based movement, handled by Rapier, controlled via JavaScript.

Networked State (Socket.io, Rapier, JS Logic):

Client sends inputs (plain JS objects) via Socket.io. Client predicts movement by stepping its local Rapier world via JavaScript calls.

Server receives inputs, validates them against its authoritative Rapier simulation and map geometry using JavaScript logic.

Server broadcasts authoritative Rapier physics states (plain JS objects containing position, rotation, etc.) and game states.

Client reconciles its predicted Rapier state with the server's authoritative state (comparing JS object values) and interpolates remote player Rapier states for smooth rendering.

Why: Creates responsive movement via client prediction, while server retains full authority using Rapier physics accessed via JavaScript.

Phase 3: Combat Systems

Objective: Introduce core shooting and damage mechanics for the 1v1 duel using JavaScript.

Tasks:

Weapon System (Three.js Visuals, Rapier Physics/Raycasting, Socket.io, JS Logic):

Implement shooting logic in JavaScript triggered by input.

Use Rapier's JavaScript API for raycasting/shape-casting from the player's camera/weapon position (derived from Rapier body state).

Simulate spread/recoil effects using JavaScript logic to modify ray direction or apply forces via Rapier's JS API.

Send hit intent/results (plain JS objects) to the server.

Server performs authoritative raycast validation within its Rapier world using Rapier's JS API, including lag compensation logic written in JavaScript.

Why: Defines the primary interaction, ensuring hit detection is physics-based via Rapier, controlled and validated using JavaScript.

Damage Model (Server JS Logic, Rapier Hitboxes):

Implement server-side health/armor state management using JavaScript variables/objects.

Define hitboxes using Rapier Collider shapes created via the JS API, attached to the player's Rapier body.

Server calculates damage in JavaScript based on validated hits against Rapier hitboxes.

Broadcast damage/health updates (JS objects). Client displays feedback via DOM manipulation using vanilla JavaScript.

Why: Determines combat outcomes based on physics-defined hit locations, calculated authoritatively on the server using JavaScript logic.

Match Flow (Server JS Logic, Client UI via DOM):

Implement server-side round timers/countdowns using JavaScript's setTimeout/setInterval.

Track scores using JavaScript variables/objects on the server.

Define victory/defeat conditions in JavaScript logic.

Broadcast match state updates. Client updates HTML HUD elements using vanilla JavaScript DOM manipulation.

Why: Structures the 1v1 duel format using server-side JavaScript logic.

Phase 4: Multiplayer Infrastructure

Objective: Scale the system to handle multiple concurrent 1v1 matches using JavaScript on the backend.

Tasks:

Matchmaking Service (Node.js Logic, potentially Redis):

Implement rating system (ELO) logic in JavaScript.

Create a queue system (e.g., using JavaScript arrays or a Redis client library for Node.js).

Match players using JavaScript logic.

Assign matched pair to an available game instance.

Why: Efficiently pairs players for 1v1 matches using JavaScript server logic.

Game Instance Isolation (Node.js):

Design the Node.js server (written in JavaScript) to run multiple, independent game instances (e.g., via child_process or worker_threads).

Implement management logic in JavaScript.

Develop basic crash recovery in JavaScript.

Why: Isolates individual duels using standard Node.js features.

State Persistence (Redis, MongoDB with JS Clients):

Use Redis/MongoDB Node.js client libraries to interact with databases from your JavaScript server code.

Store session data, match history, and player stats.

Implement leaderboard aggregation logic in JavaScript (server-side or via database queries).

Why: Maintains persistence using standard database interactions from JavaScript.

Phase 5: Optimization & Scaling

Objective: Enhance performance for many concurrent 1v1 duels, optimizing JavaScript execution where needed.

Tasks:

Network Optimization: (Same core concepts - Delta compression, Prioritization, Bandwidth throttling) Implement using JavaScript data manipulation and Socket.io configurations.

Spatial Partitioning / Interest Management: Implement algorithms in JavaScript using Rapier's query API.

Horizontal Scaling: (Same infrastructure concepts - Docker, Kubernetes, etc.) The application running inside containers is Node.js executing JavaScript.

Phase 6: Security & Anti-Cheat

Objective: Maintain fair play in the 1v1 competitive environment, validating actions within the JavaScript server logic.

Tasks:

Client Hardening: Apply JavaScript obfuscation/minification via build tools.

Server Validation (Server JS Logic, Rapier):

Implement strict server-side validation of all player actions within your JavaScript code.

Movement Plausibility: Use Rapier's JS API on the server to simulate requested moves and check for collisions against the authoritative map geometry. Write JavaScript checks for speed limits, etc.

Shot Verification: Use server-side Rapier raycasting via its JS API with lag compensation logic written in JavaScript.

Implement rate limiting in JavaScript.

Why: Leverages the server's authoritative Rapier physics (accessed via JS) and custom JavaScript logic as the ground truth. Requires careful validation as JavaScript lacks compile-time type safety.

Monitoring & Reporting: Implement logging and reporting endpoints using JavaScript server code.

Phase 7: Polish & Launch

Objective: Ship a production-ready 1v1 FPS duel experience using JavaScript.

Tasks:

Performance Tuning: Profile client-side JavaScript execution and rendering (browser dev tools), server-side Node.js performance, and Rapier simulation steps (both sides). Optimize critical JavaScript code paths.

UI & UX Polish: Refine HUD/menus using clean HTML/CSS and efficient vanilla JavaScript DOM manipulation.

Progression & Engagement: Implement systems using server-side JavaScript logic and client-side JavaScript for UI updates.

Launch Preparation: Conduct load testing, test failover, set up monitoring for the Node.js/JavaScript application stack.

Critical Path Dependencies: (Same fundamental dependencies, implemented in JavaScript)

Network Foundation

Physics Engine Setup (Client & Server with identical Map Geometry via JS)

Core Rendering Setup

Physics-Driven Movement Engine (reliant on Physics Setup, coded in JS)

This plan now reflects the use of plain JavaScript throughout the stack where applicable (client logic, server logic, shared utilities), while still leveraging the specialized libraries (Three.js, Rapier, Socket.io) via their JavaScript APIs. Remember that robust testing and clear code conventions become even more critical without TypeScript's static analysis.