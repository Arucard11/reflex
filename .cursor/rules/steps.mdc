---
description: 
globs: 
alwaysApply: true
---
Refactored 1v1 FPS Game - Detailed Plan (with Feature Integrations)

Phase 1: Foundational FPS Module Setup (Integration Aware)

Objective: Create the specific skeleton for the FPS game instance server and client component, ready to plug into the platform, now incorporating foundational elements for multiple maps, character selection, dual weapons, grenades, and grapple hooks.

1.1 FPS Game Package & Basic Structure

Goal: Establish the dedicated codebase locations and initial setup for the FPS game server instance and client component within the platform's monorepo, including definitions for the new features.

1.1.1 Setup FPS Server Instance Package (packages/game-server-fps)

Step 1: Create Directory: (No changes) In the monorepo's packages/ directory, create a new folder named game-server-fps.

Step 2: Initialize Package: (No changes) Navigate into packages/game-server-fps via terminal and run npm init -y (or yarn/pnpm). Mark as private: "private": true,.

Step 3: Add Core Dependencies: (No changes to this step, dependencies remain the same for the foundation) Install necessary Node.js libraries:

# Example using pnpm from root
pnpm add socket.io @dimforge/rapier3d-compat@^0.11.0 --filter game-server-fps
pnpm add @coral-xyz/anchor @solana/web3.js --filter game-server-fps
pnpm add yargs --filter game-server-fps
# NEW: Add three.js for server-side vector math if needed (e.g., spread calculation)
pnpm add three --filter game-server-fps
# Ensure shared types are linked via monorepo workspace protocol


socket.io: For WebSocket communication.

@dimforge/rapier3d-compat: Physics engine. Pinning version recommended.

@coral-xyz/anchor, @solana/web3.js: Solana interaction.

yargs: Command-line argument parsing.

NEW: three: While primarily a client library, its Vector/Quaternion math utilities are useful on the server (e.g., for spread calculations later) and avoid implementing custom math logic.

Step 4: Create Source Directory & Main Script: (No changes) Create src/ inside packages/game-server-fps. Inside src/, create gameInstance_fps.js.

Step 5: Define Basic Script Structure (gameInstance_fps.js): (Minor modifications for clarity)

// packages/game-server-fps/src/gameInstance_fps.js
console.log('FPS Game Instance Starting...');

// Imports (will be populated later)
const http = require('http');
const { Server } = require("socket.io");
const RAPIER = require('@dimforge/rapier3d-compat');
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');
const fs = require('fs');
// NEW: Import shared types early
const { MessageTypeFPS, MAP_CONFIGS_FPS, CHARACTER_CONFIG_FPS /*, etc */ } = require('@shared-types/game-fps'); // Adjust path based on monorepo setup

// Argument Parsing (populated in 1.2.1)
let config = {};

// Core Game State Variables (placeholders)
let rapierWorld = null;
let io = null;
let gameLoopInterval = null;
let players = {}; // Will store authoritative player state mapped by userId
let connectedPlayers = {}; // Will store socket info mapped by userId
let currentMatchState = 'loading'; // e.g., loading, waiting, countdown, in_progress, round_over, match_over

async function initialize() {
    console.log('Initializing Core Systems...');
    // Step 1: Parse Args (1.2.1) - Includes mapId, characterIds
    parseArguments();

    // Step 2: Init Rapier (1.2.2)
    await initRapier();

    // Step 3: Load Specific Map Physics (1.2.2) - Uses config.mapId
    loadMapPhysics(config.mapId);

    // Step 4: Initialize Player States (NEW: Before Socket.IO to have state ready) - Uses config.playersInfo.p1/2.charId
    initializePlayerStates();

    // Step 5: Init Socket.IO (1.2.2)
    initSocketIO();

    // Step 6: Start Game Loop (1.3.3 placeholder -> actual in Phase 2/3)
    startGameLoop();

    // Step 7: Send READY message to platform (1.2.3) - Requires Socket.IO to be listening
    signalReadyToPlatform();

    console.log('Initialization Complete.');
    currentMatchState = 'waiting'; // Ready for players to connect
}

// Placeholder functions (implementations in later steps)
function parseArguments() { /* See 1.2.1 */ }
async function initRapier() { /* See 1.2.2 */ }
function loadMapPhysics(mapId) { /* See 1.2.2 */ }
function initializePlayerStates() { /* See explanation below */ }
function initSocketIO() { /* See 1.2.2 & 1.2.3 */ }
function signalReadyToPlatform() { /* See 1.2.3 */ }
function startGameLoop() { console.log('Starting Game Loop...'); /* See 1.3.3 */ }

function shutdown() {
    console.log('Shutting down...');
    if (gameLoopInterval) clearInterval(gameLoopInterval);
    // MODIFIED: Ensure io exists before closing
    if (io) io.close();
    // TODO: Add other cleanup (Rapier world cleanup?)
    console.log('Shutdown complete.');
    process.exit(0); // Clean exit
}

// Graceful shutdown handling
process.on('SIGINT', shutdown);
process.on('SIGTERM', shutdown);

initialize().catch(err => {
    console.error("Initialization failed:", err);
    process.exit(1);
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Why: This maintains the core server structure but anticipates the need for map and character IDs from arguments (parseArguments) and initializes player states (initializePlayerStates) based on that config before accepting connections, ensuring the game world is set up correctly from the start. Added three dependency for potential server-side calculations.

Unit Test: Run node packages/game-server-fps/src/gameInstance_fps.js (will fail on arg parsing initially). Verify basic structure runs, imports are recognized (or fail clearly if path is wrong). Ensure dependencies are installed/linked.

Troubleshooting: Module not found errors, basic syntax errors.

STOP & CHECK: Dedicated Node.js package game-server-fps created with necessary core dependencies (including three). Basic runnable script gameInstance_fps.js exists with refined placeholder structure anticipating map/character selection.

1.1.2 Setup FPS Client Component (apps/web/components/games/fps/)

Step 1: Create Directory Structure: (No changes) Inside apps/web, create components/games/fps/.

Step 2: Create Main Component File: (No changes) Inside apps/web/components/games/fps/, create GameViewFPS.jsx.

Step 3: Install Client Dependencies (if needed): (No changes to dependencies themselves) Ensure apps/web has:

# Run from root, targeting the Next.js app
pnpm add three socket.io-client @dimforge/rapier3d-compat@^0.11.0 --filter web
# Potentially add types if using TS partial integration/JSDoc
pnpm add -D @types/three --filter web
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Bash
IGNORE_WHEN_COPYING_END

three: 3D rendering.

socket.io-client: Connecting to the server instance.

@dimforge/rapier3d-compat: Client-side physics (must match server).

Step 4: Define Basic Component Structure (GameViewFPS.jsx): (MODIFIED Props for map/character)

// apps/web/components/games/fps/GameViewFPS.jsx
import React, { useEffect, useRef, useState } from 'react';
// Import libs (placeholders)
// import * as THREE from 'three';
// import RAPIER from '@dimforge/rapier3d-compat';
// import { io } from 'socket.io-client';
// NEW: Import shared types early
// import { MAP_CONFIGS_FPS, CHARACTER_CONFIG_FPS /*, etc */ } from '@shared-types/game-fps'; // Adjust path

// Define props based on Universal Standard (II.1) + NEW additions
function GameViewFPS({
    serverIp,
    serverPort,
    matchId,
    localPlayerUserId,
    opponentPlayerId,
    localPlayerWallet, // Wallet adapter likely passed via Context
    opponentPlayerWallet,
    // NEW: Map and Character Selection Info
    mapId, // ID of the map selected for this match
    localPlayerCharacterId, // ID of the character selected by local player
    opponentPlayerCharacterId, // ID of the character selected by opponent
    // access useWallet() from context maybe
}) {
    const canvasRef = useRef(null);

    // State for loading/connection/game status
    const [isLoading, setIsLoading] = useState(true);
    const [connectionStatus, setConnectionStatus] = useState('disconnected');
    // NEW: Add state to hold the merged game state received from server
    const [currentGameState, setCurrentGameState] = useState(null);

    // Effect for initialization and cleanup
    useEffect(() => {
        console.log(`GameViewFPS Mounting for match: ${matchId}, Map: ${mapId}, Chars: ${localPlayerCharacterId} vs ${opponentPlayerCharacterId}`);
        const canvasElement = canvasRef.current;
        if (!canvasElement) return;

        // Abort controller for cleanup
        const abortController = new AbortController();

        // --- Initialization Logic ---
        let renderer, scene, camera, rapierWorld, socket, renderLoopId;
        // NEW: Add refs for game objects, input state, etc.
        let localPlayer = { mesh: null, rapierBody: null, mixer: null };
        let remotePlayer = { mesh: null, /* no rapierBody needed */ mixer: null };
        let fpvElements = { scene: null, camera: null, mesh: null }; // For first-person arms/weapon
        let inputState = { keys: {}, lookQuat: {x:0, y:0, z:0, w:1}, sequence: 0, pendingInputs: [] };
        let animationActions = {}; // Store loaded animations

        let isMounted = true;

        async function initGame() {
            try {
                console.log('Initializing Three.js, Rapier, Socket.io...');
                setConnectionStatus('initializing');

                // TODO: Load Shared Config (Map/Character Details) using props (mapId, etc)

                // TODO: Init Three.js Core (Scene, Camera, Renderer) (1.3.1)
                // TODO: Load Map Visuals (GLB based on mapId) (NEW - 1.3.1)
                // TODO: Load Character Visuals (Shared GLB, setup Animation Actions) (2.1.1)
                // TODO: Load FPV Arms/Weapon Visuals (Shared GLBs, one per weapon type) (2.1.2)
                // TODO: Load Grapple Gun Visuals (if any) (NEW)

                // TODO: Init Rapier Client (1.3.1)
                // TODO: Load Map Physics Geometry (Client Rapier based on mapId) (1.3.1)

                // TODO: Connect Socket.io (1.3.2) using serverIp, serverPort
                // TODO: Setup Input Listeners (Keyboard/Mouse/PointerLock) (Phase 2) - Include keys for abilities, grenades, grapple, weapon switch
                // TODO: Setup Render Loop (1.3.1)

                console.log('Client Init Placeholder Complete.');
                setIsLoading(false);
                // Status set by socket connection events later

            } catch (error) {
                console.error("Client Initialization Failed:", error);
                setConnectionStatus('error');
                setIsLoading(false);
            }
        }

        initGame();

        // --- Cleanup Logic ---
        return () => {
            console.log('GameViewFPS Unmounting, cleaning up for match:', matchId);
            isMounted = false;
            abortController.abort(); // Signal async operations to stop
            // TODO: Disconnect Socket.io (socket?.disconnect())
            // TODO: Dispose Three.js resources (renderer, geometries, materials, textures)
            // TODO: Remove Rapier world? (Check docs)
            // TODO: Remove event listeners
            // TODO: Cancel render loop (cancelAnimationFrame(renderLoopId))
            console.log("Client Cleanup Placeholder Complete.");
        };

    }, [serverIp, serverPort, matchId, mapId, localPlayerCharacterId, opponentPlayerCharacterId]); // Re-run effect if essential props change

    return (
        <div style={{ width: '100%', height: '100%', position: 'relative', background: '#222' }}>
            {/* Basic UI Placeholders */}
            {isLoading && <div>Loading Game...</div>}
            {!isLoading && connectionStatus !== 'connected' && <div>Status: {connectionStatus}</div>}
            {/* TODO: Add HUD elements driven by currentGameState (Health, Shield, Ammo, Grenades, Ability Cooldowns, Timer, Score, etc.) */}

            {/* Canvas for Three.js rendering */}
            <canvas ref={canvasRef} style={{ display: 'block', width: '100%', height: '100%' }} />

            {/* Potential UI Overlays here (Crosshair, etc.) */}
        </div>
    );
}

export default GameViewFPS;
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Jsx
IGNORE_WHEN_COPYING_END

Why: The client component needs to know which map and characters were selected for this specific match to load the correct visual assets (map GLB, character textures/config) and potentially physics geometry. Added mapId and character ID props. Added basic currentGameState state to hold the synchronized state from the server later. Added more placeholder refs for core game elements.

Tip: Pass complex objects like wallet adapters via React Context. Ensure the useEffect dependencies array includes all props that fundamentally change the game setup (like mapId).

Unit Test: Create a placeholder Next.js page rendering <GameViewFPS ... /> with mock props including the new mapId and character IDs. Verify it renders "Loading Game..." and logs the received props on mount. Verify cleanup on unmount.

Troubleshooting: Component fails render (check imports, syntax). useEffect runs unexpectedly or not at all (check dependency array).

STOP & CHECK: A React component GameViewFPS.jsx exists, accepts necessary props including mapId and character IDs, sets up basic structure with a canvas, includes useEffect for init/cleanup, and can be rendered.

1.1.3 Define FPS-Specific Shared Types (@/shared-types)

Step 1: Locate Shared Types Package: (No changes) Identify packages/shared-types.

Step 2: Create/Modify File: (No changes) E.g., packages/shared-types/src/game-fps.js or add to index.js.

Step 3: Define Constants & Structures (JavaScript): (MODIFIED Heavily to incorporate new features)

// packages/shared-types/src/game-fps.js

// --- Core Enums / Constants ---
export const GrenadeType = {
    FRAG: 'frag',
    SEMTEX: 'semtex',
    FLASHBANG: 'flashbang',
};

export const AbilityType = { // Example types
    DASH: 'dash',
    HEAL_BURST: 'heal_burst',
    DAMAGE_AMP: 'damage_amp',
    // Add more as needed
};

export const CharacterId = {
    CHAR_A: 'charA',
    CHAR_B: 'charB',
    CHAR_C: 'charC',
};

export const MapId = {
    MAP_1: 'map1',
    MAP_2: 'map2',
    MAP_3: 'map3',
};

// --- Configuration Structures ---

/**
 * @typedef {Object} WeaponConfigFPS
 * @property {string} id
 * @property {number} fireRate - ms between shots
 * @property {number} damage
 * @property {number} range
 * @property {number} baseSpread
 * @property {number} spreadIncreasePerShot
 * @property {number} maxSpread
 * @property {number} spreadRecoveryRate
 * @property {number} visualRecoilUp
 * @property {number} visualRecoilSide
 * @property {number} recoilRecoverySpeed
 * @property {number} ammoCapacity - NEW: Magazine size
 * @property {number} reloadTime - NEW: ms for reload
 * // Add properties for other weapon types (e.g., isAutomatic)
 */
export const WEAPON_CONFIG_FPS = {
    pistol: { id: 'pistol', fireRate: 300, damage: 18, range: 50, baseSpread: 0.01, spreadIncreasePerShot: 0.005, maxSpread: 0.05, spreadRecoveryRate: 0.02, visualRecoilUp: 0.1, visualRecoilSide: 0.05, recoilRecoverySpeed: 5, ammoCapacity: 12, reloadTime: 1500 },
    rifle: { id: 'rifle', fireRate: 100, damage: 25, range: 100, baseSpread: 0.02, spreadIncreasePerShot: 0.008, maxSpread: 0.08, spreadRecoveryRate: 0.03, visualRecoilUp: 0.15, visualRecoilSide: 0.08, recoilRecoverySpeed: 4, ammoCapacity: 30, reloadTime: 2500 /*, isAutomatic: true */},
    // NEW: Add sniper, shotgun, etc.
};

/**
 * @typedef {Object} GrenadeConfigFPS
 * @property {GrenadeType} type
 * @property {number} fuseTime - ms (0 for semtex impact)
 * @property {number} effectRadius
 * @property {number} damage - For frag/semtex
 * @property {number} flashDuration - For flashbang
 * // Add physics properties (mass, velocity) if needed
 */
export const GRENADE_CONFIG_FPS = {
    [GrenadeType.FRAG]: { type: GrenadeType.FRAG, fuseTime: 3000, effectRadius: 8, damage: 80 },
    [GrenadeType.SEMTEX]: { type: GrenadeType.SEMTEX, fuseTime: 2000, effectRadius: 6, damage: 70 }, // Sticks, shorter fuse
    [GrenadeType.FLASHBANG]: { type: GrenadeType.FLASHBANG, fuseTime: 1500, effectRadius: 10, flashDuration: 4000 },
};

/**
 * @typedef {Object} AbilityConfigFPS
 * @property {AbilityType} type
 * @property {number} cooldown - ms
 * @property {number} duration - ms (if applicable)
 * @property {number} effectValue - (e.g., dash distance, heal amount)
 */
export const ABILITY_CONFIG_FPS = { // Example ability details
    [AbilityType.DASH]: { type: AbilityType.DASH, cooldown: 8000, effectValue: 10 }, // 10 units dash distance
    [AbilityType.HEAL_BURST]: { type: AbilityType.HEAL_BURST, cooldown: 15000, effectValue: 50 }, // Heal 50 hp/shield combined?
    [AbilityType.DAMAGE_AMP]: { type: AbilityType.DAMAGE_AMP, cooldown: 20000, duration: 5000, effectValue: 1.2 }, // 20% damage boost for 5s
};

/**
 * @typedef {Object} CharacterConfigFPS
 * @property {CharacterId} id
 * @property {number} baseHealth
 * @property {number} baseShield
 * @property {AbilityType | null} ability1 - Which ability they have
 * // Add properties for visual variations if needed (e.g., texture paths), although models/animations are shared
 */
export const CHARACTER_CONFIG_FPS = {
    [CharacterId.CHAR_A]: { id: CharacterId.CHAR_A, baseHealth: 100, baseShield: 50, ability1: AbilityType.DASH },
    [CharacterId.CHAR_B]: { id: CharacterId.CHAR_B, baseHealth: 75, baseShield: 75, ability1: AbilityType.HEAL_BURST },
    [CharacterId.CHAR_C]: { id: CharacterId.CHAR_C, baseHealth: 125, baseShield: 25, ability1: AbilityType.DAMAGE_AMP },
};

/**
 * @typedef {Object} MapPhysicsDataFPS - Structure for physics geometry
 * @property {Array<number>} [vertices] - Optional vertex buffer
 * @property {Array<number>} [indices] - Optional index buffer for trimesh
 * @property {Array<Object>} [colliders] - Array of primitive colliders (cuboid, ball, capsule)
 * @property {Array<{x: number, y: number, z: number}>} spawnPoints - NEW: Define potential spawn locations
 */
// Example primitive collider: { type: 'cuboid', position: {x,y,z}, dimensions: {x,y,z}, rotation: {x,y,z,w} }

/**
 * @typedef {Object} MapConfigFPS
 * @property {MapId} id
 * @property {string} name - Display name
 * @property {string} visualAssetPath - Path to the map's visual GLB model
 * @property {MapPhysicsDataFPS} physicsData - The geometry for Rapier
 */
export const MAP_CONFIGS_FPS = {
    [MapId.MAP_1]: {
        id: MapId.MAP_1, name: 'Map 1', visualAssetPath: '/assets/fps_1v1/maps/map1.glb', // Corrected path example
        physicsData: {
            colliders: [
                { type: 'cuboid', position: { x: 0, y: -0.1, z: 0 }, dimensions: { x: 100, y: 0.2, z: 100 } }, // Ground
                { type: 'cuboid', position: { x: 0, y: 2, z: 15 }, dimensions: { x: 20, y: 4, z: 0.5 } }, // Wall 1
                // ... more walls, boxes, etc.
            ],
            spawnPoints: [{ x: -10, y: 1, z: 0 }, { x: 10, y: 1, z: 0 }]
        }
    },
    [MapId.MAP_2]: {
        id: MapId.MAP_2, name: 'Map 2', visualAssetPath: '/assets/fps_1v1/maps/map2.glb', // Corrected path example
        physicsData: { /* ... different colliders and spawn points ... */ spawnPoints: [{ x: 0, y: 1, z: -15 }, { x: 0, y: 1, z: 15 }] }
    },
    [MapId.MAP_3]: {
        id: MapId.MAP_3, name: 'Map 3', visualAssetPath: '/assets/fps_1v1/maps/map3.glb', // Corrected path example
        physicsData: { /* ... different colliders and spawn points ... */ spawnPoints: [{ x: -20, y: 1, z: 0 }, { x: 20, y: 1, z: 0 }] } // Example spawn points
    },
};

// --- Network Message Payloads & State ---

/**
 * @typedef {Object} PlayerInputFPS
 * @property {number} sequence - Input sequence number
 * @property {number} deltaTime - Time delta for this input batch in seconds
 * @property {{W: boolean, A: boolean, S: boolean, D: boolean, Space: boolean, Shift: boolean, Ability1: boolean, GrenadeFrag: boolean, GrenadeSemtex: boolean, GrenadeFlash: boolean, Reload: boolean, Interact: boolean, GrappleFire: boolean, WeaponSwitch: boolean}} keys - Pressed state
 * @property {{x: number, y: number, z: number, w: number}} lookQuat - Player look direction quaternion
 */

/**
 * @typedef {Object} PlayerStateFPS - Represents a player's state on the server
 * @property {string} userId
 * @property {CharacterId} characterId - NEW: Which character is being played
 * @property {string} state - e.g., 'alive', 'dead', 'spawning'
 * @property {{x: number, y: number, z: number}} position
 * @property {{x: number, y: number, z: number, w: number}} rotation
 * @property {{x: number, y: number, z: number}} velocity
 * @property {number} health
 * @property {number} shield - NEW: Replaces armor
 * @property {number} kills
 * @property {number} deaths
 * @property {number} [lastProcessedSequence] - Server confirms processed input sequence for client reconciliation
 * @property {{ semtex: number, flashbang: number, frag: number }} grenades - NEW: Uses remaining this round
 * @property {number} ability1CooldownRemaining - NEW: Cooldown timer in ms
 * @property {Array<string>} weaponSlots - NEW: IDs of equipped weapons (e.g., ['rifle', 'pistol'])
 * @property {number} activeWeaponSlot - NEW: Index (0 or 1) of the active weapon in slots
 * @property {number} currentAmmoInClip - NEW: Ammo for the active weapon
 * @property {{ active: boolean, targetPoint: {x:number, y:number, z:number} | null, startTime: number | null }} grappleState - NEW: State of the grapple gun
 * @property {boolean} isReloading - NEW: Is player currently reloading?
 * // Add other effects like isFlashed, damageAmpActive, etc.
 */

/**
 * @typedef {Object} GameStateFPS - The main state broadcast from server
 * @property {number} serverTick - Server timestamp or tick number
 * @property {MapId} mapId - NEW: Current map ID
 * @property {string} matchState - e.g., 'countdown', 'in_progress', 'round_over'
 * @property {number} timeRemaining - Seconds left in countdown or round
 * @property {number} currentRound - Current round number
 * @property {{ p1: number, p2: number }} roundWins - NEW: Rounds won by each player
 * @property {Object<string, PlayerStateFPS>} players - Map of userId to player state
 */

export const MessageTypeFPS = {
    // Platform generic types might exist, define FPS specific ones
    // Client -> Server
    PLAYER_INPUT_FPS: 'player_input_fps',
    PLAYER_FIRE_FPS: 'player_fire_fps', // Firing the active weapon
    SWITCH_WEAPON_FPS: 'switch_weapon_fps', // Request to switch active weapon slot
    RELOAD_WEAPON_FPS: 'reload_weapon_fps', // Request to reload active weapon
    THROW_GRENADE_FPS: 'throw_grenade_fps', // Includes grenade type
    USE_ABILITY_FPS: 'use_ability_fps', // Includes ability slot index (e.g., 1)
    FIRE_GRAPPLE_FPS: 'fire_grapple_fps', // Includes target point/direction
    RELEASE_GRAPPLE_FPS: 'release_grapple_fps', // Stop grappling

    // Server -> Client
    GAME_STATE_FPS: 'game_state_fps', // Full or delta game state update
    HIT_CONFIRMED_FPS: 'hit_confirmed_fps', // Server confirms your shot hit someone
    PLAYER_DIED_FPS: 'player_died_fps', // Announces a player death
    GRENADE_EXPLODED_FPS: 'grenade_exploded_fps', // Announces grenade detonation location/type
    ABILITY_USED_FPS: 'ability_used_fps', // Announces ability activation by a player
    GRAPPLE_STATE_UPDATE_FPS: 'grapple_state_update_fps', // Specific updates for grapple visuals/physics hints
    // ... other specific events like reload completion, flash effect start/end
};
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Why: Centralizes definitions for all new features. Defines IDs for maps/characters, configurations for weapons/abilities/grenades/characters/maps. Crucially updates PlayerStateFPS to include fields for shield, character ID, grenades, ability cooldowns, dual weapons, ammo, and grapple state. Adds new MessageTypeFPS for all the new actions (weapon switching, reloading, grenade throwing, ability use, grappling). This shared structure is fundamental for client-server communication.

Tip: Keep config structures easily serializable (JSON). Use enums/constants for IDs/types to prevent typos. Version these shared types if breaking changes occur later. Ensure map physics data includes spawn points.

Unit Test: Import the new structures/constants in both gameInstance_fps.js and GameViewFPS.jsx. Log some values (e.g., CHARACTER_CONFIG_FPS.charA.baseHealth, MapId.MAP_WAREHOUSE) to verify imports work across packages. Check for syntax errors in definitions.

Troubleshooting: Import errors (check paths, monorepo config). Typos in definitions. Circular dependencies if imports are structured poorly.

STOP & CHECK: Comprehensive FPS-specific types, constants, and configuration structures (maps, characters, weapons, abilities, grenades) are defined in the shared types package and are importable into server and client code. PlayerStateFPS and MessageTypeFPS reflect the new features.

1.2 Core Instance Initialization & Platform Communication

Goal: Enable the FPS game server instance to start, parse standard and new arguments, initialize basic systems (including map-specific physics), initialize player state based on character choice, and communicate readiness.

1.2.1 Implement Standard Argument Parsing (gameInstance_fps.js)

Step 1: Import Arg Parser: (No changes) const yargs = require('yargs/yargs'); const { hideBin } = require('yargs/helpers');.

Step 2: Define Expected Arguments: (MODIFIED Added mapId, player character IDs) Use yargs to define and parse arguments.

// Inside parseArguments() function or called from initialize()
const argv = yargs(hideBin(process.argv))
    .option('port', { alias: 'p', type: 'number', demandOption: true, describe: 'Port to listen on' })
    .option('matchId', { type: 'string', demandOption: true, describe: 'Unique Match ID' })
    // NEW: Map Selection
    .option('mapId', { choices: Object.values(MapId), demandOption: true, describe: 'ID of the map to load' })
    // Player Info - Use nested options or separate args
    .option('player1UserId', { type: 'string', demandOption: true })
    .option('player1Wallet', { type: 'string', demandOption: true })
    .option('player1CharId', { choices: Object.values(CharacterId), demandOption: true, describe: 'Character ID for Player 1' }) // NEW
    .option('player2UserId', { type: 'string', demandOption: true })
    .option('player2Wallet', { type: 'string', demandOption: true })
    .option('player2CharId', { choices: Object.values(CharacterId), demandOption: true, describe: 'Character ID for Player 2' }) // NEW
    // Other platform args
    .option('betAmountLamports', { type: 'number', demandOption: true })
    .option('serverAuthorityKeyPath', { type: 'string', demandOption: true, describe: 'Path to server authority keypair file' })
    .option('rpcUrl', { type: 'string', demandOption: true, describe: 'Solana RPC URL' })
    .option('platformApiUrl', { type: 'string', demandOption: true, describe: 'Platform internal API URL' })
    .option('programIdEscrow', { type: 'string', demandOption: true })
    .option('programIdProfile', { type: 'string', demandOption: true })
    .option('gameConfigPath', { type: 'string', describe: 'Optional path to override game config JSON' })
    .help()
    .alias('help', 'h')
    .parseSync(); // Or use async parse

// Store parsed args in the global 'config' object
config = {
    port: argv.port,
    matchId: argv.matchId,
    mapId: argv.mapId, // Store selected map ID
    playersInfo: {
        p1: { userId: argv.player1UserId, wallet: argv.player1Wallet, charId: argv.player1CharId }, // Store charId
        p2: { userId: argv.player2UserId, wallet: argv.player2Wallet, charId: argv.player2CharId }  // Store charId
    },
    betAmountLamports: argv.betAmountLamports,
    serverAuthorityKeyPath: argv.serverAuthorityKeyPath,
    rpcUrl: argv.rpcUrl,
    platformApiUrl: argv.platformApiUrl,
    programIds: {
        escrow: argv.programIdEscrow,
        profile: argv.programIdProfile
    },
    gameConfigPath: argv.gameConfigPath,
    // NEW: Potentially load/merge external game config here if gameConfigPath provided
    // Overriding shared types constants (WEAPON_CONFIG_FPS, etc.) if needed for tuning
};

console.log('Parsed Config:', config); // Log for verification
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 3: Handle Missing/Invalid Args: (No changes) demandOption: true and choices handle basic validation.

Why: The server instance now needs to know which map to load and which character each player chose before starting the simulation. These are passed by the Game Server Manager (which gets them from matchmaking/lobby) as command-line arguments. choices ensures only valid IDs are accepted.

Tip: Use descriptive argument names. Ensure the Game Server Manager code is updated to provide these new arguments when fork()ing the instance.

Unit Test: Launch script with new args: node ... --mapId map1 --player1CharId charA --player2CharId charB .... Verify config object logs correctly. Launch without --mapId or with invalid value; verify yargs exits with error.

Troubleshooting: yargs errors (check choices setup, demandOption). Incorrect values parsed. Script doesn't receive args (check manager's spawning command).

STOP & CHECK: FPS game instance script successfully parses required startup arguments including mapId and player charIds, stores them, and handles missing/invalid values.

1.2.2 Initialize Core Server Systems (Socket.io, Rapier) (gameInstance_fps.js)

Step 1: Import Dependencies: (Minor additions)

const RAPIER = require('@dimforge/rapier3d-compat');
const { Server } = require("socket.io");
const http = require('http');
const fs = require('fs');
// MODIFIED: Import specific configs needed here
const { MAP_CONFIGS_FPS, CHARACTER_CONFIG_FPS, WEAPON_CONFIG_FPS } = require('@shared-types/game-fps'); // Adjust path
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 2: Initialize Rapier World: (No changes to Rapier world init itself)

// Inside async initRapier() function
console.log('Initializing Rapier...');
await RAPIER.init();
const gravity = { x: 0.0, y: -9.81, z: 0.0 };
rapierWorld = new RAPIER.World(gravity);
console.log('Rapier World created.');
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 3: Load Map Physics Geometry: (MODIFIED To use mapId)

// Inside loadMapPhysics(mapId) function
console.log(`Loading Physics for Map ID: ${mapId}...`);
const mapConfig = MAP_CONFIGS_FPS[mapId];
if (!mapConfig) {
    throw new Error(`Map config not found for mapId: ${mapId}`);
}
const physicsData = mapConfig.physicsData;

// Load from colliders array (example)
if (physicsData.colliders) {
    physicsData.colliders.forEach(colliderData => {
        let colliderDesc;
        if (colliderData.type === 'cuboid') {
            colliderDesc = RAPIER.ColliderDesc.cuboid(colliderData.dimensions.x / 2, colliderData.dimensions.y / 2, colliderData.dimensions.z / 2);
        } else if (colliderData.type === 'ball') {
            // ... handle ball, capsule, etc.
        } else {
            console.warn(`Unsupported collider type: ${colliderData.type}`);
            return;
        }

        if (colliderDesc) {
            colliderDesc.setTranslation(colliderData.position.x, colliderData.position.y, colliderData.position.z);
            // TODO: Set rotation if provided
            // colliderDesc.setRotation(...)
            // TODO: Set friction, restitution, collision groups etc. if needed per collider
            colliderDesc.setCollisionGroups(interactionGroups(CollisionGroup.WORLD, [CollisionGroup.PLAYER_BODY, CollisionGroup.PLAYER_SHOOTER])); // Example groups

            // For static map geometry, typically don't need a RigidBody handle
            rapierWorld.createCollider(colliderDesc);
            console.log(`Created map collider: ${colliderData.type} at ${JSON.stringify(colliderData.position)}`);
        }
    });
}

// Load from trimesh data (vertices/indices) if provided
if (physicsData.vertices && physicsData.indices) {
    console.log(`Creating trimesh collider for map ${mapId}...`);
    const trimeshDesc = RAPIER.ColliderDesc.trimesh(physicsData.vertices, physicsData.indices);
    trimeshDesc.setCollisionGroups(interactionGroups(CollisionGroup.WORLD, [CollisionGroup.PLAYER_BODY, CollisionGroup.PLAYER_SHOOTER])); // Example groups
    rapierWorld.createCollider(trimeshDesc);
}

console.log(`Physics for Map ${mapId} Loaded.`);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Why: The server must load the correct physics geometry corresponding to the randomly selected map chosen for this match. This uses the mapId from the config to retrieve the correct physicsData from the shared MAP_CONFIGS_FPS.

Step 4: Initialize Player States: (NEW Function, called before Socket.IO init)

// Inside initializePlayerStates() function
console.log('Initializing player states...');
const p1Info = config.playersInfo.p1;
const p2Info = config.playersInfo.p2;

[p1Info, p2Info].forEach((playerInfo, index) => {
    const charConfig = CHARACTER_CONFIG_FPS[playerInfo.charId];
    if (!charConfig) {
        throw new Error(`Character config not found for charId: ${playerInfo.charId}`);
    }
    const defaultWeapon1 = 'rifle'; // Example default loadout
    const defaultWeapon2 = 'pistol';

    players[playerInfo.userId] = {
        userId: playerInfo.userId,
        wallet: playerInfo.wallet, // Store wallet for escrow later
        characterId: playerInfo.charId,
        state: 'waiting', // Initial state before spawn
        position: { x: 0, y: 1, z: 0 }, // Placeholder, will be set on spawn
        rotation: { x: 0, y: 0, z: 0, w: 1 },
        velocity: { x: 0, y: 0, z: 0 },
        health: charConfig.baseHealth, // Set from character config
        shield: charConfig.baseShield, // Set from character config
        kills: 0,
        deaths: 0,
        lastProcessedSequence: -1,
        grenades: { // Initial count per round (reset later)
            [GrenadeType.SEMTEX]: 1,
            [GrenadeType.FLASHBANG]: 1,
            [GrenadeType.FRAG]: 1,
        },
        ability1CooldownRemaining: 0, // Ability starts ready
        ability1Type: charConfig.ability1, // Store ability type
        weaponSlots: [defaultWeapon1, defaultWeapon2], // Set default dual weapons
        activeWeaponSlot: 0,
        currentAmmoInClip: WEAPON_CONFIG_FPS[defaultWeapon1]?.ammoCapacity || 0, // Start with full clip for active weapon
        grappleState: { active: false, targetPoint: null, startTime: null },
        isReloading: false,
        // Server-internal state
        rapierBody: null, // Created when player spawns/respawns
        positionHistory: [],
        inputHistory: {},
        serverLastFireTime: 0,
        currentSpread: WEAPON_CONFIG_FPS[defaultWeapon1]?.baseSpread || 0,
        // Note: Some state (like ammo/grenades/cooldowns) resets per round in Phase 3
    };
    console.log(`Initialized state for ${playerInfo.userId} (Char: ${playerInfo.charId})`);
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Why: Creates the authoritative players state object on the server before players connect. It uses the charId passed via arguments to set the correct initial health/shield based on the shared CHARACTER_CONFIG_FPS. Also initializes state for dual weapons, grenades, and abilities based on the new shared types.

Step 5: Initialize Socket.IO Server: (Logic moved to initSocketIO, minor changes for player tracking)

// Inside initSocketIO() function
console.log(`Initializing Socket.IO on port ${config.port}...`);
const httpServer = http.createServer();
io = new Server(httpServer, {
    cors: { origin: "*", methods: ["GET", "POST"] } // Restrict in prod!
});

// --- Socket.IO Connection Logic ---
io.on('connection', (socket) => {
    console.log(`Client socket connected: ${socket.id}`);

    // TODO: Add Authentication (Phase 4/Security) - Very important!
    // Verify connecting player (using token/wallet signature) matches expected player IDs/matchId from config.
    // For now, assume first two connections are the players.
    let connectedUserId = null;
    if (Object.keys(connectedPlayers).length === 0 && !connectedPlayers[config.playersInfo.p1.userId]) {
        connectedUserId = config.playersInfo.p1.userId;
    } else if (Object.keys(connectedPlayers).length === 1 && !connectedPlayers[config.playersInfo.p2.userId]) {
        connectedUserId = config.playersInfo.p2.userId;
    } else {
         console.warn(`Unexpected connection: ${socket.id}. Disconnecting.`);
         socket.disconnect(true);
         return;
    }

    console.log(`Socket ${socket.id} associated with User ID: ${connectedUserId}`);
    connectedPlayers[connectedUserId] = { socketId: socket.id, socket: socket };
    players[connectedUserId].state = 'connected'; // Update state

    // Send initial full game state to the connecting player
    socket.emit(MessageTypeFPS.GAME_STATE_FPS, getFullGameStatePayload());

    // TODO: Trigger match start countdown when both players are connected (Phase 3)
    // if (Object.keys(connectedPlayers).length === 2) { startMatchCountdown(); }

    socket.on('disconnect', (reason) => {
        console.log(`Client socket disconnected: ${socket.id}, Reason: ${reason}`);
        for (const userId in connectedPlayers) {
           if (connectedPlayers[userId]?.socketId === socket.id) {
               delete connectedPlayers[userId];
               players[userId].state = 'disconnected';
               console.log(`User ${userId} disconnected.`);
               // TODO: Handle player disconnection logic (Pause game? End match? Phase 3/4)
               break;
           }
        }
    });

    // TODO: Add handlers for game-specific messages (PLAYER_INPUT_FPS, PLAYER_FIRE_FPS, THROW_GRENADE_FPS, USE_ABILITY_FPS, etc.) (Phase 2/3)
    // Example: socket.on(MessageTypeFPS.PLAYER_INPUT_FPS, (inputData) => handlePlayerInput(connectedUserId, inputData));

});

// Listener setup moved to signalReadyToPlatform in 1.2.3
// httpServer.listen(...)
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Why: Sets up the communication server. Basic logic added to tentatively map connecting sockets to the expected player IDs (p1, p2) – this needs proper auth later. Sends the initial game state (including map/character info) when a player connects. Player state structure is now pre-initialized.

Tip: Implement robust authentication ASAP. Ensure map collider creation matches client logic precisely. Use secure CORS.

Unit Test: Start instance with valid map/char args. Verify logs show Rapier init, correct map physics loading based on ID, player state init with correct health/shield, and Socket.IO starting. Try connecting two clients; verify server logs connections and associates them (tentatively) with p1/p2. Verify clients receive initial game state.

Troubleshooting: Map config not found error (check mapId arg, MAP_CONFIGS_FPS definition). Character config error. Physics loading errors (check map data). Socket.IO errors (port conflict, CORS). Player state initialization errors.

STOP & CHECK: Server instance initializes Rapier, loads map colliders based on mapId, initializes player states based on charId (health/shield, default weapons/items), and starts Socket.IO. Tentative player association on connection exists.

1.2.3 Implement Platform Readiness Communication (gameInstance_fps.js)

Step 1: Check for IPC Channel: (No changes) const canUseIPC = typeof process.send === 'function';.

Step 2: Send READY Message: (MODIFIED To happen after listener starts)

// Inside signalReadyToPlatform() function, called after initSocketIO()
// Need access to the httpServer created in initSocketIO
const httpServer = io.httpServer; // Assuming io is accessible

httpServer.listen(config.port, () => {
    console.log(`Socket.IO server listening on port ${config.port}`);

    // --- Signal Readiness to Platform ---
    if (canUseIPC) {
        const readyMessage = {
            type: 'READY',
            serverId: config.matchId, // Use matchId as unique ID
            port: config.port
            // Add IP if needed/discoverable
        };
        try {
            process.send(readyMessage);
            console.log('Sent READY message via IPC:', readyMessage);
        } catch (error) {
            console.error('Failed to send READY message via IPC:', error);
            // Consider exiting if signalling readiness is critical
            // process.exit(1);
        }
    } else {
        console.warn('IPC not available. Cannot send READY message to manager.');
        // TODO: Implement fallback API call if needed
    }
    // --- End Signal Readiness ---

    // NO LONGER STARTS GAME LOOP HERE. Game loop waits for players.
    // startGameLoop();
    currentMatchState = 'waiting'; // Instance is ready, waiting for connections
    console.log("Instance is READY and waiting for players...");
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 3: Implement Fallback (Optional): (No changes) Consider HTTP POST fallback if IPC unreliable.

Why: Notifies the Game Server Manager that this instance is initialized (including map/player setup) and listening for connections on its assigned port. Separated listener start from signalling readiness. The game loop shouldn't start until players connect (handled in Phase 3).

Tip: Ensure the Manager's handler correctly parses the READY message. Handle process.send errors.

Unit Test: (Requires Spawner). Launch via spawner. Verify spawner receives READY message after instance logs "Socket.IO server listening...". Check Redis registry updated by spawner.

Troubleshooting: process.send not a function (not launched via fork). Message not received. IPC channel errors. Redis update fails in manager.

STOP & CHECK: Upon successful initialization and starting the Socket.IO listener, the FPS game instance sends a 'READY' message to the platform manager.

1.3 Core Client Component Setup & Connection

Goal: Enable the FPS client component to initialize rendering/physics for the specific map, load shared character assets, and connect to its assigned game server instance.

1.3.1 Initialize Client Systems (Three.js, Rapier) (GameViewFPS.jsx)

Step 1: Import Dependencies: (Minor additions)

import React, { useEffect, useRef, useState, useCallback } from 'react';
import * as THREE from 'three';
import RAPIER from '@dimforge/rapier3d-compat';
// NEW: GLTFLoader import
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
// NEW: SkeletonUtils for cloning animated models
import * as SkeletonUtils from 'three/examples/jsm/utils/SkeletonUtils.js';
// Assuming shared types are resolved
import { MAP_CONFIGS_FPS, CHARACTER_CONFIG_FPS, WEAPON_CONFIG_FPS /*, etc */ } from '@shared-types/game-fps'; // Adjust path
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
Jsx
IGNORE_WHEN_COPYING_END

Step 2: Initialization Logic: (MODIFIED Heavily for map/character loading) Flesh out initGame inside useEffect.

// Inside useEffect -> initGame() function

// --- Access Config based on Props ---
const mapConfig = MAP_CONFIGS_FPS[mapId];
const localCharConfig = CHARACTER_CONFIG_FPS[localPlayerCharacterId];
const remoteCharConfig = CHARACTER_CONFIG_FPS[opponentPlayerCharacterId];
if (!mapConfig || !localCharConfig || !remoteCharConfig) {
    throw new Error("Missing required map or character config on client!");
}

// --- Asset Loaders ---
const loader = new GLTFLoader();
const textureLoader = new THREE.TextureLoader(); // For potential texture variations

// --- Three.js Core Setup ---
renderer = new THREE.WebGLRenderer({ canvas: canvasElement, antialias: true });
renderer.setSize(canvasElement.clientWidth, canvasElement.clientHeight);
renderer.setPixelRatio(window.devicePixelRatio);
renderer.shadowMap.enabled = true;

scene = new THREE.Scene();
scene.background = new THREE.Color(0x6699cc); // Example sky blue

camera = new THREE.PerspectiveCamera(75, canvasElement.clientWidth / canvasElement.clientHeight, 0.1, 1000);
camera.position.set(0, 1.6, 5); // Initial placeholder position
scene.add(camera);

// Basic Lighting
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
directionalLight.position.set(10, 15, 5);
directionalLight.castShadow = true; // Enable shadows
scene.add(directionalLight);

// --- Load Map Visuals (NEW) ---
console.log(`Loading visual map: ${mapConfig.visualAssetPath}`);
const mapGltf = await loader.loadAsync(mapConfig.visualAssetPath);
const mapMesh = mapGltf.scene;
mapMesh.traverse(node => { // Enable shadows on map objects
    if (node.isMesh) {
        node.castShadow = true;
        node.receiveShadow = true;
    }
});
scene.add(mapMesh);
console.log(`Map ${mapId} visuals loaded.`);

// --- Load Shared Character Model (NEW - logic from 2.1.1 adapted) ---
console.log("Loading shared character model...");
// Assume one shared model, potentially different textures per character later
const characterGltf = await loader.loadAsync('/assets/fps_1v1/models/player.glb'); // Shared model path
// Store animations globally
animationActions = {};
characterGltf.animations.forEach(clip => {
    animationActions[clip.name] = clip; // Store clips by name
});
// Clone model for local and remote players
localPlayer.mesh = SkeletonUtils.clone(characterGltf.scene);
remotePlayer.mesh = SkeletonUtils.clone(characterGltf.scene);
// TODO: Apply character-specific textures if CHARACTER_CONFIG defines them
localPlayer.mesh.traverse(node => { if (node.isMesh) node.castShadow = true; });
remotePlayer.mesh.traverse(node => { if (node.isMesh) node.castShadow = true; });
scene.add(localPlayer.mesh);
scene.add(remotePlayer.mesh);
localPlayer.mesh.visible = false; // Hide until state received
remotePlayer.mesh.visible = false;
// Create animation mixers
localPlayer.mixer = new THREE.AnimationMixer(localPlayer.mesh);
remotePlayer.mixer = new THREE.AnimationMixer(remotePlayer.mesh);
console.log("Character model loaded and cloned.");

// --- Load FPV Arms/Weapons (NEW - logic from 2.1.2 adapted) ---
console.log("Loading FPV assets...");
fpvElements.scene = new THREE.Scene(); // Separate scene for overlay
fpvElements.camera = new THREE.PerspectiveCamera(60, canvasElement.clientWidth / canvasElement.clientHeight, 0.01, 100);
// Load models for ALL potential weapons (pistol, rifle, etc.)
fpvElements.weaponModels = {}; // Store loaded FPV models by weapon ID
for (const weaponId in WEAPON_CONFIG_FPS) {
    try {
        const fpvGltf = await loader.loadAsync(`/assets/fps_1v1/models/fpv_${weaponId}.glb`); // e.g., fpv_rifle.glb
        fpvGltf.scene.traverse(node => { if(node.isMesh) node.frustumCulled = false; }); // Prevent overlay culling
        fpvElements.weaponModels[weaponId] = fpvGltf.scene;
         // Add to FPV scene but keep invisible initially
        fpvGltf.scene.visible = false;
        fpvElements.scene.add(fpvGltf.scene);
    } catch (e) {
         console.warn(`Could not load FPV model for ${weaponId}: ${e}`);
    }
}
console.log("FPV assets loaded.");
// Active weapon model visibility handled in render loop based on state

// --- Load Grapple Visuals (NEW - Placeholder) ---
// Example: Load a simple line material for the rope
fpvElements.grappleRopeMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, linewidth: 2 });
// Actual rope geometry created/updated dynamically in render loop

// --- Rapier Setup ---
console.log('Initializing Client Rapier...');
await RAPIER.init();
rapierWorld = new RAPIER.World({ x: 0.0, y: -9.81, z: 0.0 });
console.log('Client Rapier World created.');

// --- Load Map Physics (Client - Mirroring server 1.2.2) ---
console.log(`Loading Client Physics for Map ID: ${mapId}...`);
const clientPhysicsData = mapConfig.physicsData;
// Identical loading logic as server (from 1.2.2 Step 3)
// Create colliders using clientPhysicsData.colliders or .vertices/.indices
// Ensure collision groups match server setup!
// Example for ground plane:
if (clientPhysicsData.colliders?.find(c => c.type === 'cuboid' && c.dimensions.y < 1)) { // Simple ground check
    const groundColliderData = clientPhysicsData.colliders.find(c => c.type === 'cuboid' && c.dimensions.y < 1);
    const groundColliderDesc = RAPIER.ColliderDesc.cuboid(groundColliderData.dimensions.x / 2, groundColliderData.dimensions.y / 2, groundColliderData.dimensions.z / 2)
        .setTranslation(groundColliderData.position.x, groundColliderData.position.y, groundColliderData.position.z)
        .setCollisionGroups(interactionGroups(CollisionGroup.WORLD, [CollisionGroup.PLAYER_BODY, CollisionGroup.PLAYER_SHOOTER])); // Match server groups
    rapierWorld.createCollider(groundColliderDesc);
    console.log('Created client ground collider.');
} // ... load all other map colliders ...
console.log('Client Map Physics Loaded.');

// --- Resize Handling ---
const handleResize = () => { /* ... no changes ... */ };
window.addEventListener('resize', handleResize, { signal: abortController.signal });
handleResize();

// --- Render Loop ---
let lastTimestamp = performance.now();
const render = (timestamp) => {
    if (!isMounted) return;
    renderLoopId = requestAnimationFrame(render);

    const deltaTime = Math.min(0.05, (timestamp - lastTimestamp) / 1000); // Clamp delta time
    lastTimestamp = timestamp;

    // --- Game Logic Updates (Detailed in Phase 2/3) ---
    // 1. Process Inputs (Keyboard/Mouse -> inputState) (Phase 2)
    // 2. Send Input to Server (Socket emit PLAYER_INPUT_FPS) (Phase 2)
    // 3. Client Prediction: Apply local input to localPlayer.rapierBody (Phase 2)
    // 4. Step Client Physics World (rapierWorld.step()) (Phase 2)
    // 5. State Updates from Server (Apply received currentGameState)
    //    - Reconciliation: Correct localPlayer.rapierBody state, re-sim pending inputs (Phase 2)
    //    - Interpolation: Calculate remotePlayer visual position/rotation (Phase 2)
    // 6. Update Visuals from Physics/State
    //    - Update localPlayer.mesh position/rotation from localPlayer.rapierBody
    //    - Update remotePlayer.mesh position/rotation from interpolation buffer
    //    - Update Animation Mixers (localPlayer.mixer.update, remotePlayer.mixer.update) (Phase 2)
    //    - Update Camera (FPV/TPV logic, link to lookQuat) (Phase 2)
    //    - Update FPV Weapon Visibilty/Transform (based on activeWeaponSlot, sync with camera) (Phase 2)
    //    - Update Grapple Rope Visuals (if grappleState.active) (Phase 2)
    // 7. Render Scene(s)
    if (renderer && scene && camera) {
        // Render main scene
        renderer.render(scene, camera);

        // Render FPV overlay if in first person view
        if (fpvElements.scene && fpvElements.camera /* && isFirstPerson */) {
             // Update active FPV weapon model visibility based on currentGameState.players[localPlayerUserId].activeWeaponSlot
             // Ensure fpvCamera rotation matches main camera rotation
             fpvElements.camera.quaternion.copy(camera.quaternion);
             renderer.autoClear = false; // Prevent clearing main scene render
             renderer.clearDepth(); // Clear depth buffer only
             renderer.render(fpvElements.scene, fpvElements.camera);
             renderer.autoClear = true;
        }
    }
};
renderLoopId = requestAnimationFrame(render); // Start the loop
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 3: Resource Cleanup: (MODIFIED To dispose loaded assets)

// Inside useEffect return () => { ... }
console.log('Cleaning up Three.js, Rapier, listeners...');
window.removeEventListener('resize', handleResize); // Or use abortController signal
cancelAnimationFrame(renderLoopId);

// Dispose Three.js objects
scene?.traverse(object => { /* ... dispose geometry/material ... */ });
fpvElements?.scene?.traverse(object => { /* ... dispose geometry/material ... */ }); // Dispose FPV assets too
renderer?.dispose();

// Dispose Rapier world? Check docs.
// rapierWorld?.free();

console.log("Client Cleanup Complete.");
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Why: Sets up client rendering and physics based on the specific mapId. Loads the visual assets for the map and the shared character model. Prepares the FPV overlay system by loading all weapon models. Initializes Rapier physics using the correct map geometry. Establishes the render loop structure which will be filled in later phases. Resource cleanup is crucial.

Tip: Use async/await for loading assets. Handle loading errors gracefully. Use SkeletonUtils for cloning animated models. Ensure client physics setup mirrors the server exactly.

Unit Test: Mount component with valid map/char props. Verify Three.js canvas renders scene background. Check Network tab/console for map/character/weapon GLB loading requests. Verify Rapier initializes and loads map colliders from the correct config. Resize window; verify rendering adapts. Unmount; verify cleanup logs. Check for WebGL errors.

Troubleshooting: Asset loading errors (404 Not Found, CORS issues, invalid GLB). Rapier init errors. Map colliders mismatch server. WebGL context lost. Memory leaks from improper disposal. Performance issues loading large map/character assets.

STOP & CHECK: Client component initializes Three.js, loads the correct visual map asset based on mapId, loads the shared character model, FPV weapon assets, initializes RapierJS with correct map physics, handles resizing, starts the render loop, and cleans up resources.

1.3.2 Establish Game Instance Connection (GameViewFPS.jsx)

Step 1: Import Socket.IO Client: (No changes) import { io } from 'socket.io-client';.

Step 2: Connection Logic: (MODIFIED To store socket ref, use setCurrentGameState) Add Socket.io connection within initGame.

// Inside useEffect -> initGame() function

console.log(`Attempting to connect to game server: ws://${serverIp}:${serverPort}`);
// Assign to variable declared in outer scope (accessible by cleanup)
socket = io(`ws://${serverIp}:${serverPort}`, {
    // Optional: Add query params for auth (Phase 4/Security)
    // query: { matchId: matchId, userId: localPlayerUserId, token: '...' },
    reconnectionAttempts: 3,
    timeout: 5000,
});

socket.on('connect', () => {
    if (!isMounted) return;
    console.log('Successfully connected to game server. Socket ID:', socket.id);
    setConnectionStatus('connected');
    // TODO: Send authentication/join message if required by server
});

socket.on('disconnect', (reason) => {
    if (!isMounted) return;
    console.log('Disconnected from game server. Reason:', reason);
    setConnectionStatus('disconnected');
    setCurrentGameState(null); // Clear game state on disconnect
    // TODO: Handle disconnection UI/navigation
});

socket.on('connect_error', (error) => {
    if (!isMounted) return;
    console.error('Connection error to game server:', error);
    setConnectionStatus('error');
    // TODO: Show error message
});

// --- State Sync Listener (Moved from 1.3.3) ---
const { MessageTypeFPS } = await import('@shared-types/game-fps'); // Ensure types available

socket.on(MessageTypeFPS.GAME_STATE_FPS, (gameState) => {
    if (!isMounted) return;
    // TODO: Implement proper delta merging (Phase 5)
    // For now, just replace state (or basic merge if full state sent initially)
    setCurrentGameState(prevState => ({
         ...(prevState || {}), // Keep previous state if delta
         ...gameState // Overwrite with new/changed data
     }));
    // Reconciliation/Interpolation logic will use currentGameState in render loop
});
```*   **Step 3: Disconnection on Cleanup:** (No changes)
```javascript
// Inside useEffect return () => { ... }
socket?.disconnect();
console.log('Socket disconnected.');
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Why: Connects the client to the specific server instance. Handles connection events. Crucially, adds the listener for GAME_STATE_FPS here and updates the component's currentGameState state variable, which will drive the UI and game logic updates in the render loop.

Tip: Implement proper authentication. Handle disconnects gracefully. Use constants for message types.

Unit Test: Requires running server instance. Mount component. Verify client logs connection attempt and success. Verify server logs connection. Stop server; verify client logs disconnect. Unmount; verify socket disconnected. Verify client receives initial GAME_STATE_FPS and currentGameState state updates.

Troubleshooting: Connection errors (check IP/port, server status, firewall, CORS). Socket undefined errors. Client state not updating on message receive.

STOP & CHECK: Client component establishes Socket.io connection, handles events, cleans up connection, and has a listener to update its currentGameState state when GAME_STATE_FPS messages are received.

1.3.3 Basic State Synchronization Placeholder (GameViewFPS.jsx, gameInstance_fps.js)

Step 1: Server Emit State (gameInstance_fps.js): (MODIFIED To send richer initial state, loop moved) The main game loop (setInterval) logic for broadcasting state should actually start in Phase 3 when the match begins. However, we need a way to send the initial state when a client connects.

// Function to generate the full state payload
function getFullGameStatePayload() {
    const playerStates = {};
    for (const userId in players) {
        playerStates[userId] = getSerializablePlayerState(userId); // Helper needed
    }

    return {
         serverTick: Date.now(), // Or tick counter
         mapId: config.mapId, // Include map ID
         matchState: currentMatchState, // Current server match state
         timeRemaining: 0, // No timer yet
         currentRound: 1, // Default round
         roundWins: { p1: 0, p2: 0 }, // Default wins
         players: playerStates
    };
}

// Helper to extract serializable player state (adapt as needed)
function getSerializablePlayerState(userId) {
    const pState = players[userId];
    if (!pState) return null;
    return {
        userId: pState.userId,
        characterId: pState.characterId,
        state: pState.state,
        position: pState.position,
        rotation: pState.rotation,
        velocity: pState.velocity,
        health: pState.health,
        shield: pState.shield,
        kills: pState.kills,
        deaths: pState.deaths,
        lastProcessedSequence: pState.lastProcessedSequence, // Send to client for reconciliation
        grenades: pState.grenades,
        ability1CooldownRemaining: pState.ability1CooldownRemaining,
        weaponSlots: pState.weaponSlots,
        activeWeaponSlot: pState.activeWeaponSlot,
        currentAmmoInClip: pState.currentAmmoInClip,
        grappleState: pState.grappleState,
        isReloading: pState.isReloading,
    };
}

// Remove the setInterval from startGameLoop for now.
// The initial state send happens in the io.on('connection') handler (Step 5 in 1.2.2)
// The periodic broadcast loop will be added in Phase 3 (e.g., inside startRound).
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 2: Client Receive State (GameViewFPS.jsx): (Listener already added in 1.3.2) The socket.on(MessageTypeFPS.GAME_STATE_FPS, ...) handler now updates the currentGameState state variable. The render loop (placeholder in 1.3.1) will be responsible for using this state for display and prediction/interpolation in later phases.

Why: Ensures the client receives a complete initial picture of the game state (including map, character selections, initial health/shield, loadouts) immediately upon connecting. The periodic broadcasting mechanism is deferred until the match actually starts (Phase 3) to avoid unnecessary traffic. The client now stores this received state in its React state (currentGameState).

Tip: Define getSerializablePlayerState carefully to only include data the client needs. Ensure the initial state sent is accurate based on server config.

Unit Test: Connect client. Verify client receives initial GAME_STATE_FPS message upon connection. Log the received gameState object and verify it contains the correct mapId, initial player states (health/shield based on char config), default weapons, grenade counts, etc. Check the client's currentGameState state variable is updated.

Troubleshooting: Client doesn't receive initial state (check server emit logic in connection handler). State structure mismatch (verify getSerializablePlayerState matches shared types). Client state variable not updating (check setCurrentGameState call).

STOP & CHECK: Server sends a comprehensive initial game state upon client connection. Client receives and stores this state. Periodic state broadcasts are deferred to later phases.

This completes the integration of the new features into the refactored plan for Phases 1 and 2. We have established the necessary data structures, configurations, argument passing, and initial state setup to support multiple maps, character selection with differing stats, dual weapons, grenades, and grapple hooks, all within the foundational client/server structure.

Okay, I have the original plan for Phases 3, 4, and 5. I will now integrate the requested features into these phases, building upon the foundation laid in Phases 1 and 2.

Phase 3: Combat Systems (Integrated - with Feature Additions)

Objective: Implement shooting, weapon management (dual guns, reload), grenades, abilities, grapple hooks, damage mechanics, and round flow logic, ensuring server authority and incorporating character differences.

3.1 Weapon System (Client Input -> Server Raycast/Validation)

Goal: Implement shooting using server-authoritative Rapier raycasting, manage dual weapons, ammo, and reloading, with client providing immediate feedback and triggering actions.

3.1.1 Raycast Shooting (Client Intent -> Server Rapier castRay)

Step 1: Client Input Handling (GameViewFPS.jsx): (No changes to basic fire detection, but context changes)

Attach mousedown/mouseup (for automatic fire) or track fire key state.

Maintain client-side state: lastClientFireTime, isFiring.

Import necessary shared types: WEAPON_CONFIG_FPS, MessageTypeFPS.

NEW: Get the activeWeaponId from the local player's state within the currentGameState received from the server (e.g., currentGameState.players[localPlayerUserId].weaponSlots[currentGameState.players[localPlayerUserId].activeWeaponSlot]).

Step 2: Client Fire Logic (GameViewFPS.jsx): (MODIFIED Uses active weapon state)

Check Fire Rate/Ammo (Client-Side Prediction):

const localPlayerState = currentGameState?.players?.[localPlayerUserId];
if (!localPlayerState || localPlayerState.state !== 'alive' || localPlayerState.isReloading) return; // Cannot fire if dead/reloading

const activeWeaponSlot = localPlayerState.activeWeaponSlot;
const activeWeaponId = localPlayerState.weaponSlots[activeWeaponSlot];
const weaponConfig = WEAPON_CONFIG_FPS[activeWeaponId];
if (!weaponConfig) return; // No weapon equipped?

const now = Date.now();
// Prevent client spamming fire message
if (now - lastClientFireTime < weaponConfig.fireRate * 0.8) { // Slightly lenient client check
    return;
}
// Check ammo prediction (optional, server is authority)
if (localPlayerState.currentAmmoInClip <= 0) {
    // Trigger reload? Play 'empty click' sound?
    // handleReload(); // Or rely on player pressing reload key
    return;
}
lastClientFireTime = now;
// Decrement predicted ammo (optional, server state overrides)
// setPredictedAmmo(prev => prev - 1);


Determine Ray Origin/Direction: (No change) Use camera.position / camera.getWorldDirection().

Instant Visual/Audio Feedback: (No change) Trigger muzzle flash, play sound based on activeWeaponId. Apply visual recoil (see 3.1.2).

Send Fire Event: (MODIFIED Payload unchanged, context relies on server knowing active weapon)

const fireData = {
    // Origin/Direction calculation might be refined later
    origin: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
    direction: { x: directionVector.x, y: directionVector.y, z: directionVector.z },
    sequence: inputState.sequence // Link shot timing to input sequence
};
socket.emit(MessageTypeFPS.PLAYER_FIRE_FPS, fireData);
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 3: Server Receive Fire Event (gameInstance_fps.js): (MODIFIED Uses active weapon state, includes ammo check)

// Inside io.on('connection', (socket) => { ... })
socket.on(MessageTypeFPS.PLAYER_FIRE_FPS, (fireData) => {
    const playerId = getPlayerIdFromSocket(socket); // Function to map socket.id to userId
    if (!playerId || !players[playerId] || players[playerId].state !== 'alive' || players[playerId].isReloading) return; // Basic validation

    const playerState = players[playerId];
    // --- Get Active Weapon ---
    const activeWeaponId = playerState.weaponSlots[playerState.activeWeaponSlot];
    const weaponConfig = WEAPON_CONFIG_FPS[activeWeaponId];
    if (!weaponConfig) {
        console.warn(`Player ${playerId} tried to fire with invalid weapon slot: ${playerState.activeWeaponSlot}`);
        return;
    }

    // --- Server-Side Ammo Check (Authoritative) ---
    if (playerState.currentAmmoInClip <= 0) {
        console.warn(`Player ${playerId} tried to fire empty weapon ${activeWeaponId}.`);
        // Optionally send 'empty clip' feedback?
        return; // Reject shot
    }

    // --- Server-Side Fire Rate Check (Authoritative) ---
    const now = Date.now();
    if (now - playerState.serverLastFireTime < weaponConfig.fireRate) {
        console.warn(`Player ${playerId} exceeded fire rate for ${activeWeaponId}.`);
        return; // Reject shot
    }
    playerState.serverLastFireTime = now; // Update only if shot proceeds

    // --- Lag Compensation / Get Authoritative State (3.1.3) ---
    // ... (logic remains the same, uses fireData.sequence)
    const authoritativeState = getPlayerAuthoritativeStateAtSequence(playerId, fireData.sequence);
    const authoritativeOrigin = authoritativeState.position;
    const authoritativeDirection = getInputDirectionFromSequence(playerId, fireData.sequence);

    // --- Apply Spread (3.1.2 - Uses active weapon config) ---
    const fireDirectionWithSpread = applySpread(authoritativeDirection, playerState, weaponConfig);

    // --- Decrement Ammo (Authoritative) ---
    playerState.currentAmmoInClip--;
    console.log(`Player ${playerId} ammo for ${activeWeaponId}: ${playerState.currentAmmoInClip}/${weaponConfig.ammoCapacity}`);


    // --- Perform Raycast (logic remains the same, uses fireDirectionWithSpread, weaponConfig.range) ---
    console.log(`Player ${playerId} firing ${activeWeaponId}. Seq: ${fireData.sequence}. Dir: ${JSON.stringify(fireDirectionWithSpread)}`);
    const ray = new RAPIER.Ray(authoritativeOrigin, fireDirectionWithSpread);
    const hit = rapierWorld.castRayAndGetNormal(...); // Use filters, range from weaponConfig

    if (hit) {
        // ... Process Hit (Damage Model - 3.2, uses weaponConfig.damage)
        processHit(playerId, hit.collider, hit.collider.getUserData(), hit.pointAt(hit.toi), hit.normal, weaponConfig.damage);
    } else {
         console.log(`Player ${playerId} MISS with ${activeWeaponId}`);
    }

    // Broadcast updated ammo state via GAME_STATE_FPS (or dedicated message)
    broadcastGameState(); // Ensure this broadcast includes the updated ammo count
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 4: Collision Groups Setup (Server): (No changes) Setup remains crucial (World, Player Body, Player Hitbox, Player Shooter groups).

Why: Shooting logic now correctly references the player's currently active weapon from their weaponSlots. Server performs authoritative ammo checks before allowing the shot and decrements ammo count. Client-side checks prevent unnecessary network spam. Damage/Range now come from the active weapon's config.

Tip: Ensure broadcastGameState (or delta updates) includes currentAmmoInClip and activeWeaponSlot so the client HUD is accurate.

Unit Test: Equip Rifle (slot 0). Fire; verify server uses Rifle config (damage, range, fire rate, ammo). Switch to Pistol (slot 1). Fire; verify server uses Pistol config. Empty clip; fire; verify server rejects shot and logs ammo empty. Verify client HUD updates ammo count.

Troubleshooting: Server uses wrong weapon config (check activeWeaponSlot state). Ammo counts desync (server state update/broadcast issue). Raycast range/damage incorrect (check weapon config values).

STOP & CHECK: Shooting uses the config of the active weapon slot. Server authoritatively checks/decrements ammo and validates fire rate. Client gets visual feedback.

3.1.2 Bullet spread/recoil patterns

(No fundamental changes needed here due to other features. The logic remains the same but operates on the weaponConfig of the active weapon, retrieved in 3.1.1)

Server applies spread based on playerState.currentSpread and the active weaponConfig.

Server recovers spread based on playerState.serverLastFireTime and active weaponConfig.

Client applies visual recoil based on active weaponConfig.

STOP & CHECK: Server spread and client visual recoil correctly use parameters from the currently active weapon's configuration.

3.1.3 Hit registration (client/server sync - Rapier context)

(No fundamental changes needed here due to other features. Lag compensation logic remains the same.)

Server stores position/input history.

Server uses fireData.sequence to determine fire time.

Server rewinds shooter/target positions based on fire time.

Server performs checks (LoS, angle) and hitbox raycast using rewound state and direction from input history.

Server restores positions.

Server sends HIT_CONFIRMED_FPS to shooter if compensated check hits.

Client displays hitmarker on receipt.

STOP & CHECK: Lag compensation correctly uses input sequence numbers and position history to perform authoritative hit checks based on player positions at the time of firing intent.

NEW: 3.1.4 Weapon Switching & Reloading

Goal: Allow players to switch between their two equipped weapons and reload them.

Step 1: Client Input Handling (GameViewFPS.jsx):

Add key listeners for "Switch Weapon" (e.g., '1', '2', 'Q', mouse wheel) and "Reload" (e.g., 'R').

In the input handler:

If Switch Weapon pressed: Determine target slot (0 or 1). Send SWITCH_WEAPON_FPS message with the target slot index. Provide instant client feedback (e.g., start weapon lowering animation).

If Reload pressed: Check if current weapon needs reload (currentAmmoInClip < ammoCapacity). Send RELOAD_WEAPON_FPS message. Provide instant client feedback (start reload animation, play sound).

// Example input handler snippet
function handleKeyDown(event) {
    // ... other keys ...
    if (event.key === 'q' || event.key === 'Q') { // Example switch key
        const currentSlot = currentGameState?.players?.[localPlayerUserId]?.activeWeaponSlot;
        if (currentSlot !== undefined) {
            const nextSlot = (currentSlot + 1) % 2; // Cycle between 0 and 1
            console.log('Client: Requesting switch to weapon slot', nextSlot);
            socket.emit(MessageTypeFPS.SWITCH_WEAPON_FPS, { targetSlot: nextSlot });
            // Play weapon down animation immediately
            playAnimation(fpvElements.weaponModels[currentWeaponId], 'weapon_down');
        }
    } else if (event.key === 'r' || event.key === 'R') {
        console.log('Client: Requesting reload');
        const playerState = currentGameState?.players?.[localPlayerUserId];
        const weaponId = playerState?.weaponSlots?.[playerState?.activeWeaponSlot];
        const weaponConfig = WEAPON_CONFIG_FPS[weaponId];
        // Client-side check to avoid spamming (optional)
        if (playerState && weaponConfig && playerState.currentAmmoInClip < weaponConfig.ammoCapacity && !playerState.isReloading) {
             socket.emit(MessageTypeFPS.RELOAD_WEAPON_FPS);
             // Play reload animation/sound immediately
             playAnimation(fpvElements.weaponModels[weaponId], 'reload');
        }
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 2: Server Handling (gameInstance_fps.js): Add handlers for the new messages.

// --- Switch Weapon Handler ---
socket.on(MessageTypeFPS.SWITCH_WEAPON_FPS, (data) => {
    const playerId = getPlayerIdFromSocket(socket);
    if (!playerId || !players[playerId] || players[playerId].state !== 'alive') return;
    const playerState = players[playerId];

    const targetSlot = data.targetSlot;
    if (targetSlot === undefined || (targetSlot !== 0 && targetSlot !== 1) || targetSlot === playerState.activeWeaponSlot || playerState.isReloading) {
         console.warn(`Player ${playerId}: Invalid weapon switch request.`);
         return; // Ignore invalid slot or switch during reload
    }

    console.log(`Player ${playerId}: Switching to weapon slot ${targetSlot}`);
    playerState.activeWeaponSlot = targetSlot;
    // Update ammo count to the newly active weapon's clip (Important!)
    const newWeaponId = playerState.weaponSlots[targetSlot];
    const newWeaponConfig = WEAPON_CONFIG_FPS[newWeaponId];
    playerState.currentAmmoInClip = playerState[`ammoInClipSlot${targetSlot}`] ?? newWeaponConfig?.ammoCapacity ?? 0; // Need to store ammo per slot
    // Reset spread for the new weapon
    playerState.currentSpread = newWeaponConfig?.baseSpread ?? 0;

    // TODO: Add a short cooldown/delay for weapon switching?
    playerState.isReloading = false; // Cancel any pending reload on switch

    broadcastGameState(); // Inform clients of the new active slot and ammo
});

// --- Reload Weapon Handler ---
socket.on(MessageTypeFPS.RELOAD_WEAPON_FPS, () => {
    const playerId = getPlayerIdFromSocket(socket);
    if (!playerId || !players[playerId] || players[playerId].state !== 'alive' || players[playerId].isReloading) return;
    const playerState = players[playerId];

    const activeWeaponId = playerState.weaponSlots[playerState.activeWeaponSlot];
    const weaponConfig = WEAPON_CONFIG_FPS[activeWeaponId];

    if (!weaponConfig || playerState.currentAmmoInClip >= weaponConfig.ammoCapacity) {
        console.warn(`Player ${playerId}: Cannot reload ${activeWeaponId} (already full or invalid).`);
        return; // Ignore if already full or invalid weapon
    }

    console.log(`Player ${playerId}: Starting reload for ${activeWeaponId}`);
    playerState.isReloading = true;
    // Store current ammo for the inactive slot if needed
    playerState[`ammoInClipSlot${playerState.activeWeaponSlot}`] = playerState.currentAmmoInClip;

    broadcastGameState(); // Inform clients that reload has started

    // Set timer for reload completion
    setTimeout(() => {
        // Double check player still exists, is alive, and is still trying to reload this weapon
        if (players[playerId] && players[playerId].state === 'alive' && players[playerId].isReloading && players[playerId].weaponSlots[players[playerId].activeWeaponSlot] === activeWeaponId) {
            players[playerId].currentAmmoInClip = weaponConfig.ammoCapacity;
            players[playerId].isReloading = false;
            console.log(`Player ${playerId}: Reload complete for ${activeWeaponId}`);
            broadcastGameState(); // Inform clients reload finished, ammo updated
        } else {
             console.log(`Player ${playerId}: Reload cancelled for ${activeWeaponId}`);
             // Restore ammo count if switch happened? Requires tracking ammo per slot properly.
             if (players[playerId]) players[playerId].isReloading = false; // Ensure flag is reset
             broadcastGameState(); // Send state update even if cancelled
        }
    }, weaponConfig.reloadTime);
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

NEW State Needed: Server playerState needs to store ammo per weapon slot, e.g., ammoInClipSlot0, ammoInClipSlot1. When switching, currentAmmoInClip should be loaded from the corresponding slot variable. When reloading, it refills currentAmmoInClip and updates the corresponding slot variable.

Step 3: Client State Handling/Feedback (GameViewFPS.jsx):

In the render loop or state update handler, use currentGameState.players[localPlayerUserId].activeWeaponSlot to determine which FPV weapon model in fpvElements.weaponModels should be visible.

Play weapon up/down animations when activeWeaponSlot changes in received state.

Use currentGameState.players[localPlayerUserId].isReloading to play/manage reload animations on the active FPV weapon model. Ensure animations sync with server reloadTime.

Display currentAmmoInClip and total ammo (if tracked) on the HUD based on received state.

Why: Implements the core logic for managing two weapons, allowing players to switch between them and perform reloads, all validated and timed by the server. Client provides immediate animation feedback for responsiveness. Requires careful state management for ammo per weapon slot.

Tip: Ensure reload can be interrupted by weapon switching, sprinting (if added), or other actions. Decide how total ammo reserves work (shared pool, per weapon?). Store ammo per slot robustly on server state.

Unit Test: Start game. Press switch key; verify client plays anims, server updates activeWeaponSlot, broadcasts state, client FPV model/HUD updates. Fire weapon partially, press reload; verify client plays anim, server sets isReloading, broadcasts state. Wait for reloadTime; verify server updates ammo, clears isReloading, broadcasts, client HUD updates. Try switching weapon mid-reload; verify server cancels reload timer and switches weapon state.

Troubleshooting: Weapon doesn't switch visually or functionally (state update/broadcast issue). Reload animation/timing desyncs from server (check timers, state updates). Ammo counts incorrect after switching/reloading (check slot ammo storage logic). Reload interruption logic buggy.

STOP & CHECK: Players can switch between two equipped weapons and reload the active weapon. Server validates actions, manages timers/state, and clients receive updates for visual/HUD feedback.

3.2 Damage Model (Server Instance Authority)

Goal: Define damage application based on hits, manage health/shield state, incorporate character base stats, and handle death/respawn.

3.2.1 Health/Shield management system (gameInstance_fps.js)

Step 1: Define Initial State: (MODIFIED Based on Character Choice) This was done in the modified Phase 1.2.2 (initializePlayerStates), which now uses charConfig.baseHealth and charConfig.baseShield.

Step 2: Implement Damage Rules: (MODIFIED Shield takes precedence) Define rules: Damage reduces Shield first, then Health.

Step 3: Create applyDamage Function: (MODIFIED For Shield)

function applyDamage(victimPlayerId, damageAmount, hitPart /*, killerPlayerId passed in now */) {
    const victimState = players[victimPlayerId];
    // NEW: Pass killerPlayerId into applyDamage
    const killerPlayerId = currentKillerId; // Assumes currentKillerId set before call

    if (!victimState || victimState.state === 'dead') return;

    console.log(`Applying ${damageAmount} damage to ${victimPlayerId} (Hit: ${hitPart || 'body'}) from ${killerPlayerId}`);

    let damageToShield = 0;
    let damageToHealth = damageAmount; // Assume all damage goes to health initially

    // --- Apply Shield Rules ---
    if (victimState.shield > 0) {
        damageToShield = Math.min(victimState.shield, damageAmount); // Shield absorbs up to its current value
        damageToHealth = damageAmount - damageToShield; // Health takes the remainder

        victimState.shield -= damageToShield;
        victimState.shield = Math.max(0, victimState.shield); // Clamp shield at 0
        console.log(`Shield reduced by ${damageToShield}, remaining: ${victimState.shield}`);
    }
    // --- End Shield Rules ---

    // Apply remaining damage to health
    if (damageToHealth > 0) {
         victimState.health -= damageToHealth;
         victimState.health = Math.max(0, victimState.health); // Clamp health at 0
         console.log(`Health reduced by ${damageToHealth}, remaining: ${victimState.health}`);
    }

    broadcastGameState(); // Ensure updated health/shield sent

    // Check for death
    if (victimState.health <= 0) {
        // Pass killer ID explicitly
        handlePlayerDeath(victimPlayerId, killerPlayerId);
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 4: Integrate with Hit Processing: (MODIFIED Pass killer ID)

function processHit(shooterPlayerId, hitCollider, hitUserData, hitPoint, hitNormal, baseDamage) {
    if (hitUserData?.type === 'playerHitbox') {
        const victimPlayerId = hitUserData.playerId;
        const hitPart = hitUserData.part || 'body';
        // ... (check victim state) ...

        const multiplier = HITBOX_MULTIPLIERS[hitPart] || 1.0;
        const finalDamage = baseDamage * multiplier;

        // Set killer context BEFORE calling applyDamage
        currentKillerId = shooterPlayerId;
        applyDamage(victimPlayerId, finalDamage, hitPart);
        currentKillerId = null; // Reset context after use
    } else { /* ... */ }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 5: Implement handlePlayerDeath: (Minor changes for clarity)

function handlePlayerDeath(victimPlayerId, killerPlayerId) { // KillerId passed directly
     const victimState = players[victimPlayerId];
     if (victimState.state === 'dead') return;

     console.log(`${victimPlayerId} killed by ${killerPlayerId || 'Environment/Self'}`);
     victimState.state = 'dead';
     victimState.health = 0;
     victimState.shield = 0; // Reset shield on death

     victimState.deaths++;
     if (killerPlayerId && killerPlayerId !== victimPlayerId && players[killerPlayerId]) {
         players[killerPlayerId].kills++;
         // TODO: Grant kill credit for assists?
     }

     const deathData = { victimId: victimPlayerId, killerId: killerPlayerId };
     io.emit(MessageTypeFPS.PLAYER_DIED_FPS, deathData);

     // Disable physics / move body (same as before)
     disablePlayerPhysics(victimState.rapierBody);

     // Start Respawn Timer
     setTimeout(() => { respawnPlayer(victimPlayerId); }, RESPAWN_DELAY_MS);

     checkEndConditions();
}
// Helper function for disabling physics
function disablePlayerPhysics(rapierBody) {
    if (rapierBody) {
        rapierBody.setLinvel({x:0,y:0,z:0}, true);
        rapierBody.setAngvel({x:0,y:0,z:0}, true);
        rapierBody.setGravityScale(0, true);
        rapierBody.setTranslation({x:0, y:-1000, z:0}, true); // Move underground/away
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 6: Implement respawnPlayer: (MODIFIED Uses map spawn points, resets shield/ability/grenades)

function respawnPlayer(playerId) {
    const playerState = players[playerId];
    if (!playerState || playerState.state !== 'dead') return;

    // Find spawn point using map config
    const mapConfig = MAP_CONFIGS_FPS[config.mapId];
    const spawnPoints = mapConfig?.physicsData?.spawnPoints || [{x: 0, y: 1, z: 0}]; // Default spawn
    // Simple alternating spawn:
    const spawnIndex = (playerId === config.playersInfo.p1.userId) ? 0 : 1;
    const spawnPoint = spawnPoints[spawnIndex % spawnPoints.length];

    console.log(`Respawning ${playerId} at ${JSON.stringify(spawnPoint)}`);

    // Reset State using Character Config
    const charConfig = CHARACTER_CONFIG_FPS[playerState.characterId];
    playerState.state = 'alive';
    playerState.health = charConfig.baseHealth;
    playerState.shield = charConfig.baseShield; // Reset shield based on character

    // NEW: Reset per-round consumables/cooldowns
    playerState.grenades = { [GrenadeType.SEMTEX]: 1, [GrenadeType.FLASHBANG]: 1, [GrenadeType.FRAG]: 1 };
    playerState.ability1CooldownRemaining = 0;
    playerState.isReloading = false;
    // Reset ammo to full for both weapon slots
    const weaponId0 = playerState.weaponSlots[0];
    const weaponId1 = playerState.weaponSlots[1];
    playerState.currentAmmoInClip = WEAPON_CONFIG_FPS[playerState.weaponSlots[playerState.activeWeaponSlot]]?.ammoCapacity ?? 0;
    playerState[`ammoInClipSlot0`] = WEAPON_CONFIG_FPS[weaponId0]?.ammoCapacity ?? 0;
    playerState[`ammoInClipSlot1`] = WEAPON_CONFIG_FPS[weaponId1]?.ammoCapacity ?? 0;
    playerState.currentSpread = WEAPON_CONFIG_FPS[playerState.weaponSlots[playerState.activeWeaponSlot]]?.baseSpread ?? 0;

    // Reset Physics Body (using helper)
    resetPlayerPhysics(playerState.rapierBody, spawnPoint);

    broadcastGameState(); // Inform clients of respawn and reset state
    console.log(`${playerId} respawned.`);
}
// Helper function for resetting physics
function resetPlayerPhysics(rapierBody, position) {
    if (rapierBody) {
        rapierBody.setTranslation(position, true);
        rapierBody.setLinvel({ x: 0, y: 0, z: 0 }, true);
        rapierBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
        rapierBody.setGravityScale(1, true);
        rapierBody.wakeUp();
    } else {
         // If body doesn't exist yet (first spawn), need to create it here
         // players[playerId].rapierBody = createPlayerPhysicsBody(playerId, position); // Logic from 3.2.2
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 7: Sync State (gameInstance_fps.js): (No changes) broadcastGameState needs to include Health and Shield.

Step 8: Client Feedback (GameViewFPS.jsx): (MODIFIED Display Shield) Update HUD to display both Health and Shield based on currentGameState. Other logic (death screen, input disable/enable) remains similar.

Why: Damage now correctly depletes Shield before Health. Initial Health/Shield values are derived from the selected character's config. Respawn logic now resets Shield, uses map-defined spawn points, and importantly, resets per-round resources like grenades and ability cooldowns, and refills ammo.

Tip: Consider shield regeneration logic (start delay, regen rate) if desired, add it to the server game loop. Ensure spawn points are defined well in map configs. createPlayerPhysicsBody needs to be called initially if rapierBody is null on first respawn attempt.

Unit Test: Test characters with different base health/shield; verify initial values and damage application order. Verify spawn points from map config are used. Verify grenades/ability cooldowns are reset after respawn. Test damage application during shield regen (if implemented).

Troubleshooting: Incorrect health/shield values (check char config, damage logic). Player spawns in wrong location (check map config, spawn logic). Grenades/abilities not resetting (check respawnPlayer logic).

STOP & CHECK: Server manages health/shield based on character choice, applies damage correctly (shield first), handles death/respawn using map spawn points, and resets per-round resources upon respawn. Client HUD shows health/shield.

3.2.2 Hitbox configuration per character (Rapier Colliders) (gameInstance_fps.js)

(No fundamental changes needed here due to other features. The logic for creating a main body collider and separate hitbox colliders (head, torso, etc.) attached to it remains the same.)

The key is that createPlayerPhysicsBody (called during initial spawn/respawn if body doesn't exist) sets up these colliders correctly with userData identifying the playerId and part.

The size/position of these hitboxes could be adjusted slightly per character if desired (making one character slightly wider/taller physically), but the plan specified shared animations/models, so shared hitbox configuration is likely intended.

STOP & CHECK: Server creates appropriate Rapier physics body and hitbox colliders for players, enabling location-based damage. Configuration is likely shared across characters based on shared models/animations.

3.2.3 Server-side damage calculation (Consolidation) (gameInstance_fps.js)

(No fundamental changes needed here due to other features. The principle remains paramount.)

Re-verify that all steps (fire rate, ammo, lag comp, raycast, hitbox check, damage amount, shield/health application) use only server-authoritative state and configurations. Client input (look direction) is used but validated within server constraints.

STOP & CHECK: Confirmed through review that all damage calculation logic, including shield interaction, remains exclusively server-authoritative.

NEW: 3.3 Grenade System

Goal: Implement throwing physics, detonation, and effects for Frag, Semtex, and Flashbang grenades, with usage limited per round.

Step 1: Client Input & Prediction (GameViewFPS.jsx):

Add key listener for "Throw Grenade Frag/Semtex/Flash" (e.g., 'G', 'H', 'J' or cycle key).

Check currentGameState if player has the selected grenade type available (grenades[type] > 0).

If available:

Predict trajectory (simple physics calculation or Rapier client-side prediction). Render a visual arc/indicator.

On throw confirmation (e.g., mouse click while holding key): Send THROW_GRENADE_FPS message including grenadeType and initial direction (from camera) and potentially calculated initial velocity.

Instantiate a temporary grenade visual object client-side and simulate its predicted path using basic physics or client Rapier (needs separate Rapier world or careful filtering).

// Example client-side grenade throw request
function handleThrowGrenade(grenadeType) {
    const playerState = currentGameState?.players?.[localPlayerUserId];
    if (playerState && playerState.grenades[grenadeType] > 0 && !playerState.isReloading /* && !isThrowingGrenade */) {
        console.log(`Client: Requesting throw ${grenadeType}`);
        const direction = camera.getWorldDirection(new THREE.Vector3());
        const throwData = {
            type: grenadeType,
            direction: { x: direction.x, y: direction.y, z: direction.z },
            // velocity: // optional initial velocity magnitude
            sequence: inputState.sequence // Link to input state
        };
        socket.emit(MessageTypeFPS.THROW_GRENADE_FPS, throwData);
        // Predict trajectory, show visual indicator, play throw animation/sound
        // predictGrenadeThrow(grenadeType, direction);
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 2: Server Handling (gameInstance_fps.js): Add handler for THROW_GRENADE_FPS.

// Active grenades state (store server-side physics objects)
let activeGrenades = {}; // Map by unique grenade ID
let nextGrenadeId = 0;

socket.on(MessageTypeFPS.THROW_GRENADE_FPS, (data) => {
    const playerId = getPlayerIdFromSocket(socket);
    if (!playerId || !players[playerId] || players[playerId].state !== 'alive') return;
    const playerState = players[playerId];
    const grenadeType = data.type;

    // --- Authoritative Check ---
    if (!grenadeType || !playerState.grenades[grenadeType] || playerState.grenades[grenadeType] <= 0) {
        console.warn(`Player ${playerId} tried to throw invalid/unavailable grenade: ${grenadeType}`);
        return;
    }

    // --- Consume Grenade ---
    playerState.grenades[grenadeType]--;
    console.log(`Player ${playerId} threw ${grenadeType}. Remaining: ${JSON.stringify(playerState.grenades)}`);
    broadcastGameState(); // Update client HUDs

    // --- Get Throw State (Lag Compensated?) ---
    // Optional: Could use lag compensated position/direction like shooting
    const throwSequence = data.sequence;
    const throwerState = getPlayerAuthoritativeStateAtSequence(playerId, throwSequence);
    const throwDirection = getInputDirectionFromSequence(playerId, throwSequence); // Use look direction
    const origin = calculateThrowOrigin(throwerState.position); // Slightly in front of player

    // --- Create Grenade Physics Object ---
    const grenadeId = `g_${nextGrenadeId++}`;
    const grenadeConfig = GRENADE_CONFIG_FPS[grenadeType];
    const grenadeRadius = 0.1; // Example size
    const grenadeBodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(origin.x, origin.y, origin.z)
        .setLinvel(throwDirection.x * 20, throwDirection.y * 20, throwDirection.z * 20) // Example initial velocity
        .setCcdEnabled(true); // Enable CCD for fast moving small object
    const grenadeBody = rapierWorld.createRigidBody(grenadeBodyDesc);
    const grenadeColliderDesc = RAPIER.ColliderDesc.ball(grenadeRadius)
         // TODO: Define Grenade collision groups (interacts with World, Players?)
        .setCollisionGroups(interactionGroups(CollisionGroup.GRENADE, [CollisionGroup.WORLD, CollisionGroup.PLAYER_BODY]))
        .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS) // Need collision events for sticking
        .setRestitution(0.5) // Bounciness
        .setDensity(1.0);
    const grenadeCollider = rapierWorld.createCollider(grenadeColliderDesc, grenadeBody);

    // Store grenade state
    activeGrenades[grenadeId] = {
        id: grenadeId,
        type: grenadeType,
        body: grenadeBody,
        collider: grenadeCollider,
        ownerId: playerId,
        startTime: Date.now(),
        fuseTimer: null,
        isSticking: grenadeType === GrenadeType.SEMTEX, // Flag for semtex
        isStuck: false,
    };

    // --- Start Fuse Timer (if applicable) ---
    if (grenadeConfig.fuseTime > 0) {
        activeGrenades[grenadeId].fuseTimer = setTimeout(() => {
            detonateGrenade(grenadeId);
        }, grenadeConfig.fuseTime);
    }
    // Semtex might detonate on impact OR timer, handle in collision event
});

// Need collision event handler for Semtex sticking
// rapierWorld.emit('collision', (body1, body2, started) => { /* ... check if grenade hit player/world */ });
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 3: Server Grenade Update & Detonation (gameInstance_fps.js):

In the main server game loop, include grenade positions/rotations in the GAME_STATE_FPS broadcast (or a separate message) so clients can render them accurately.

Implement detonateGrenade(grenadeId):

Get grenade state from activeGrenades.

Find detonation position (grenade body position).

Clear fuse timer.

Perform effects based on grenadeType:

Frag/Semtex: Use Rapier query (intersectionsWithShape with a Ball) to find nearby players within effectRadius. Calculate damage based on distance. Apply damage using applyDamage.

Flashbang: Use Rapier query to find nearby players. Check Line of Sight (raycast) from detonation point to player head position. Check player look angle relative to flash. If flashed, set a playerState.isFlashedUntil timestamp. Broadcast flash effect start/end.

Broadcast GRENADE_EXPLODED_FPS message with position, type, effects.

Remove grenade body/collider from Rapier world and activeGrenades map.

function detonateGrenade(grenadeId) {
    const grenade = activeGrenades[grenadeId];
    if (!grenade) return;

    const position = grenade.body.translation();
    const grenadeConfig = GRENADE_CONFIG_FPS[grenade.type];

    console.log(`Grenade ${grenadeId} (${grenade.type}) detonating at ${JSON.stringify(position)}`);
    clearTimeout(grenade.fuseTimer); // Ensure timer cleared

    // Broadcast explosion effect first (visuals/sound)
    io.emit(MessageTypeFPS.GRENADE_EXPLODED_FPS, { id: grenadeId, type: grenade.type, position: position });

    // Apply effects
    if (grenade.type === GrenadeType.FRAG || grenade.type === GrenadeType.SEMTEX) {
        // Query for nearby players and apply damage
        const explosionShape = new RAPIER.Ball(grenadeConfig.effectRadius);
        rapierWorld.intersectionsWithShape(position, {w:1}, explosionShape, /* filters */, (collider) => {
            const userData = collider.getUserData();
            if (userData?.type === 'playerHitbox' && players[userData.playerId]) {
                 const victimPos = players[userData.playerId].rapierBody.translation(); // Use body pos
                 const distance = Math.max(0.1, position.distanceTo(victimPos)); // Avoid zero distance
                 // Simple linear falloff example
                 const damageScale = Math.max(0, 1.0 - (distance / grenadeConfig.effectRadius));
                 const damage = Math.round(grenadeConfig.damage * damageScale);
                 if (damage > 0) {
                     currentKillerId = grenade.ownerId; // Set killer context
                     applyDamage(userData.playerId, damage, `explosion_${grenade.type}`);
                     currentKillerId = null;
                 }
            }
            return true; // Continue query
        });
    } else if (grenade.type === GrenadeType.FLASHBANG) {
        // Query for nearby players, check LoS, check angle, apply flash state
        // ... implementation requires raycasts and angle checks ...
        // if (shouldBeFlashed) { players[victimId].isFlashedUntil = Date.now() + grenadeConfig.flashDuration; }
    }

    // Cleanup
    rapierWorld.removeCollider(grenade.collider, false); // false = don't wake bodies
    rapierWorld.removeRigidBody(grenade.body);
    delete activeGrenades[grenadeId];
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 4: Client Visuals & Effects (GameViewFPS.jsx):

Render grenade models based on server state updates (activeGrenades positions in GAME_STATE_FPS).

Listen for GRENADE_EXPLODED_FPS. Play explosion visual/audio effects at the specified position based on type.

If local player is flashed (playerState.isFlashedUntil > Date.now()), apply screen effect (e.g., whiteout, audio muffle).

Why: Implements the full grenade lifecycle: client initiates throw, server validates, simulates physics using Rapier, handles detonation timing/conditions, calculates effects authoritatively (damage, flash), and informs clients for visual/audio feedback. Limits usage per round.

Tip: Use CCD for grenade physics. Optimize Rapier queries for explosion effects. Implement Semtex sticking logic using collision events and potentially Rapier joints. Flashbang logic needs careful LoS and angle checks. Grenade visuals on client should interpolate smoothly based on server updates.

Unit Test: Throw each grenade type. Verify server consumes grenade count. Verify grenade physics object created. Verify trajectory/bouncing. Verify detonation at correct time/condition. Test Frag/Semtex damage application at different distances. Test Flashbang effect application (requires state logging/mocking). Verify client plays correct effects based on received messages.

Troubleshooting: Grenade count incorrect. Grenade physics unstable (CCD needed?). Detonation timer wrong. Explosion damage calculation inaccurate. Flashbang effect not working or applying incorrectly. Semtex doesn't stick. Client visuals desync from server grenade positions.

STOP & CHECK: Players can throw Frag, Semtex, and Flashbang grenades (1 each per round). Server simulates physics, handles detonation, applies effects authoritatively (damage/flash), and updates clients.

NEW: 3.4 Ability System

Goal: Implement character-specific abilities with cooldowns, triggered by player input and validated/executed by the server.

Step 1: Client Input (GameViewFPS.jsx):

Add key listener for "Use Ability 1" (e.g., 'E', 'F').

Check currentGameState if ability1CooldownRemaining <= 0.

If ready, send USE_ABILITY_FPS message. Include ability slot index (e.g., abilitySlot: 1). Provide instant client feedback (sound, visual effect start).

// Example client-side ability request
function handleUseAbility() {
    const playerState = currentGameState?.players?.[localPlayerUserId];
    if (playerState && playerState.ability1CooldownRemaining <= 0 && playerState.state === 'alive' /* && !isUsingAbility */) {
        console.log(`Client: Requesting use ability ${playerState.ability1Type}`);
        socket.emit(MessageTypeFPS.USE_ABILITY_FPS, { abilitySlot: 1 });
        // Play ability activation sound/visual immediately
        // playAbilityFX(playerState.ability1Type);
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 2: Server Handling (gameInstance_fps.js): Add handler for USE_ABILITY_FPS.

socket.on(MessageTypeFPS.USE_ABILITY_FPS, (data) => {
    const playerId = getPlayerIdFromSocket(socket);
    if (!playerId || !players[playerId] || players[playerId].state !== 'alive') return;
    const playerState = players[playerId];
    const abilitySlot = data.abilitySlot; // Currently only slot 1

    // --- Authoritative Check ---
    if (abilitySlot !== 1 || playerState.ability1CooldownRemaining > 0) {
         console.warn(`Player ${playerId} tried to use invalid/on-cooldown ability.`);
         return;
    }

    const abilityType = playerState.ability1Type;
    const abilityConfig = ABILITY_CONFIG_FPS[abilityType];
    if (!abilityConfig) {
         console.error(`Player ${playerId} has invalid ability type: ${abilityType}`);
         return;
    }

    // --- Activate Ability & Start Cooldown ---
    console.log(`Player ${playerId} activating ability: ${abilityType}`);
    playerState.ability1CooldownRemaining = abilityConfig.cooldown;
    startAbilityCooldownTimer(playerId, 1); // Helper to decrement cooldown over time

    // --- Apply Ability Effects (Server-Side) ---
    applyAbilityEffect(playerId, abilityType, abilityConfig);

    // Broadcast state change (cooldown started)
    broadcastGameState();
    // Broadcast specific ability use event for effects
    io.emit(MessageTypeFPS.ABILITY_USED_FPS, { playerId: playerId, abilityType: abilityType });
});

// Helper to manage cooldown timers
function startAbilityCooldownTimer(playerId, slotIndex) {
    const playerState = players[playerId];
    if (!playerState) return;
    // Simple interval check in game loop
    // Or precise timeout:
    const interval = 100; // Check every 100ms
    const timer = setInterval(() => {
        if (!players[playerId] || players[playerId].state === 'dead') { // Stop if player gone/dead
             clearInterval(timer);
             return;
        }
        players[playerId].ability1CooldownRemaining -= interval;
        if (players[playerId].ability1CooldownRemaining <= 0) {
             players[playerId].ability1CooldownRemaining = 0;
             clearInterval(timer);
             console.log(`Player ${playerId} ability ${slotIndex} off cooldown.`);
             broadcastGameState(); // Update HUD
        }
    }, interval);
    // Need to store and clear these timers properly on disconnect/death/match end
}

// Helper to apply effects
function applyAbilityEffect(playerId, abilityType, abilityConfig) {
    const playerState = players[playerId];
    const rapierBody = playerState.rapierBody;
    if (!rapierBody) return;

    switch (abilityType) {
        case AbilityType.DASH:
            const dashDirection = getPlayerLookDirection(rapierBody.rotation()); // Get current look direction
            const dashImpulse = {
                x: dashDirection.x * abilityConfig.effectValue,
                y: 1.0, // Small upward boost?
                z: dashDirection.z * abilityConfig.effectValue
            };
            rapierBody.applyImpulse(dashImpulse, true);
            console.log(`Applied dash impulse to ${playerId}`);
            break;
        case AbilityType.HEAL_BURST:
            const healAmount = abilityConfig.effectValue;
            let healedShield = Math.min(CHARACTER_CONFIG_FPS[playerState.characterId].baseShield - playerState.shield, healAmount);
            playerState.shield += healedShield;
            let healedHealth = Math.min(CHARACTER_CONFIG_FPS[playerState.characterId].baseHealth - playerState.health, healAmount - healedShield);
            playerState.health += healedHealth;
            console.log(`Applied heal burst to ${playerId}: +${healedShield} Shield, +${healedHealth} Health`);
            break;
        case AbilityType.DAMAGE_AMP:
            playerState.damageAmpActiveUntil = Date.now() + abilityConfig.duration;
            console.log(`Applied damage amp to ${playerId} for ${abilityConfig.duration}ms`);
            // Damage calculation logic (processHit) needs to check this flag
            break;
        // Add other abilities
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

NEW State Needed: Server playerState needs damageAmpActiveUntil timestamp (or similar flags for other buff/debuff effects). processHit needs to check playerState.damageAmpActiveUntil > Date.now() for the shooter and apply multiplier if active.

Step 3: Client Visuals & Feedback (GameViewFPS.jsx):

Listen for ABILITY_USED_FPS. Play corresponding visual/audio effects for the player who used the ability (e.g., dash trail, heal aura, damage amp glow).

Display ability1CooldownRemaining on the HUD, updating based on currentGameState. Grey out/indicate ability readiness.

If local player gets affected by an opponent's ability (e.g., opponent uses damage amp), show relevant feedback if desired.

Why: Implements character-specific active abilities, adding another layer to combat. Server validates cooldowns, applies physics/state effects authoritatively, and manages cooldown timers. Clients trigger the action and receive updates for effects and HUD.

Tip: Design ability effects carefully for balance. Ensure cooldown timers are managed robustly (cleared on death/disconnect). Damage calculation needs to incorporate buffs/debuffs from abilities.

Unit Test: Use each character type. Press ability key when ready; verify server validates, applies effect (check logs/state for dash impulse, health/shield increase, damage amp flag), starts cooldown, broadcasts state. Verify client plays effects and HUD updates cooldown. Press ability key while on cooldown; verify server rejects it.

Troubleshooting: Cooldown timers incorrect or not clearing. Ability effects not applying correctly (physics impulse wrong, state flags not set/checked). Client effects/HUD don't match server state. Balancing issues between abilities.

STOP & CHECK: Players can use their character-specific ability. Server validates cooldowns, applies effects authoritatively, and manages cooldowns. Client provides feedback and HUD updates.

NEW: 3.5 Grapple Gun System

Goal: Implement a grapple gun mechanic available to all characters for enhanced movement.

Step 1: Client Input & Targeting (GameViewFPS.jsx):

Add key listener for "Fire Grapple" (e.g., right mouse button, 'F').

On key press: Perform a client-side raycast (using THREE.Raycaster against visual map meshes, or clientRapierWorld.castRay against physics colliders) from the camera outwards to find a potential grapple point within range (e.g., 30 units).

If a valid point is found: Send FIRE_GRAPPLE_FPS message with the targetPoint coordinates. Render a visual indicator of the grapple hook traveling towards the target.

Add key listener for "Release Grapple" (e.g., same key again, or 'Ctrl'). Send RELEASE_GRAPPLE_FPS.

// Example client-side grapple request
function handleFireGrapple() {
    const playerState = currentGameState?.players?.[localPlayerUserId];
    if (playerState && playerState.state === 'alive' && !playerState.grappleState.active /* && grappleCooldownReady */) {
        // Perform client raycast
        const raycaster = new THREE.Raycaster(camera.position, camera.getWorldDirection(new THREE.Vector3()));
        // Intersect with scene.children, filter for map objects/specific grapple surfaces
        const intersects = raycaster.intersectObjects(scene.children, true); // Recursive check

        let validHit = null;
        const GRAPPLE_MAX_RANGE = 30;
        for (const hit of intersects) {
            // Add checks: is hit object grappleable? Is it within range? Is it not the player itself?
            if (hit.object.userData.isGrappleable && hit.distance < GRAPPLE_MAX_RANGE) {
                validHit = hit.point;
                break;
            }
        }

        if (validHit) {
            console.log(`Client: Firing grapple towards ${JSON.stringify(validHit)}`);
            socket.emit(MessageTypeFPS.FIRE_GRAPPLE_FPS, { targetPoint: { x: validHit.x, y: validHit.y, z: validHit.z } });
            // Show grapple hook projectile visual traveling towards point
            // showGrappleProjectile(validHit);
        } else {
             console.log("Client: Grapple target not found/out of range.");
             // Play failure sound?
        }
    }
}
function handleReleaseGrapple() {
    const playerState = currentGameState?.players?.[localPlayerUserId];
    if (playerState && playerState.grappleState.active) {
         console.log("Client: Requesting grapple release.");
         socket.emit(MessageTypeFPS.RELEASE_GRAPPLE_FPS);
    }
}
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 2: Server Handling (gameInstance_fps.js): Add handlers for FIRE_GRAPPLE_FPS and RELEASE_GRAPPLE_FPS.

socket.on(MessageTypeFPS.FIRE_GRAPPLE_FPS, (data) => {
    const playerId = getPlayerIdFromSocket(socket);
    if (!playerId || !players[playerId] || players[playerId].state !== 'alive' || players[playerId].grappleState.active) return;
    const playerState = players[playerId];
    const targetPoint = data.targetPoint;

    if (!targetPoint) return;

    const playerBody = playerState.rapierBody;
    if (!playerBody) return;
    const playerPos = playerBody.translation();

    // --- Authoritative Validation ---
    const distance = playerPos.distanceTo(targetPoint);
    const GRAPPLE_MAX_RANGE_SERVER = 31; // Slightly more lenient than client
    if (distance > GRAPPLE_MAX_RANGE_SERVER) {
        console.warn(`Player ${playerId}: Grapple target out of range (Server check).`);
        return;
    }
    // Perform server raycast to confirm LoS and valid surface
    const direction = { x: targetPoint.x - playerPos.x, y: targetPoint.y - playerPos.y, z: targetPoint.z - playerPos.z };
    const ray = new RAPIER.Ray(playerPos, direction);
    const hit = rapierWorld.castRay(ray, distance + 0.1, true, /* filters for static world */);

    if (!hit || hit.toi > distance + 0.05) { // Check if ray hit something solid near the target point
         console.warn(`Player ${playerId}: Grapple target point obstructed or invalid (Server check).`);
         return;
    }
    const actualHitPoint = ray.pointAt(hit.toi); // Use the actual hit point

    // --- Activate Grapple ---
    console.log(`Player ${playerId}: Grapple attached to ${JSON.stringify(actualHitPoint)}`);
    playerState.grappleState = {
        active: true,
        targetPoint: actualHitPoint, // Store actual validated hit point
        startTime: Date.now(),
        // TODO: Store joint handle if using Rapier joints
    };
    // TODO: Apply physics effect (e.g., create Rapier joint, or apply continuous impulse)
    // Option A: Impulse towards target (simpler) - Apply in game loop
    // Option B: Rapier.Joint (more complex, potentially more stable) - Create joint here

    broadcastGameState(); // Inform clients grapple is active
    // Or send specific GRAPPLE_STATE_UPDATE_FPS
});

socket.on(MessageTypeFPS.RELEASE_GRAPPLE_FPS, () => {
    const playerId = getPlayerIdFromSocket(socket);
    if (!playerId || !players[playerId] || !players[playerId].grappleState.active) return;
    const playerState = players[playerId];

    console.log(`Player ${playerId}: Releasing grapple.`);
    // TODO: Remove physics effect (remove joint, stop applying impulse)
    playerState.grappleState = { active: false, targetPoint: null, startTime: null };

    broadcastGameState(); // Inform clients grapple released
});
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

Step 3: Server Physics Application (gameInstance_fps.js - Game Loop):

If using impulse approach: In the game loop, if playerState.grappleState.active:

Calculate vector from player position to grappleState.targetPoint.

Normalize the vector.

Apply an impulse or force along that vector to playerState.rapierBody. Tune force magnitude.

Optionally: Dampen velocity perpendicular to the grapple direction.

Check if player reached target, maybe auto-release?

If using Rapier Joints (e.g., RAPIER.SpringJoint): Create the joint in the FIRE_GRAPPLE_FPS handler, attaching the player body to a static point or body at the targetPoint. Remove the joint in the RELEASE_GRAPPLE_FPS handler.

Step 4: Client Visuals (GameViewFPS.jsx):

Based on currentGameState.players[localPlayerUserId].grappleState:

If active, render a line (using THREE.Line with LineBasicMaterial or similar) from the player's FPV weapon model origin to the grappleState.targetPoint. Update the line geometry vertices each frame.

Show grapple hook model at targetPoint?

Play reeling sound/visual effect.

Why: Adds a significant movement mechanic. Client performs initial targeting raycast for responsiveness. Server validates target range/LoS authoritatively and applies the physics forces using Rapier, ensuring consistency. Clients render the visual effect based on server state.

Tip: Impulse method is simpler to start with. Joint method offers more complex physics interactions but requires careful setup/tuning. Tune grapple speed/force for good feel. Decide on cooldown for grapple. Ensure server LoS check uses appropriate collision groups. Client visual raycast should ideally use geometry closely matching server physics colliders.

Unit Test: Fire grapple at valid surface in range; verify server validates, sets grappleState.active, applies physics force (check player velocity/position changes). Verify client renders rope visual. Release grapple; verify server clears state, stops force, client removes rope. Fire at point out of range/obstructed; verify server rejects it.

Troubleshooting: Grapple doesn't attach (client raycast fail, server validation fail - range/LoS). Player physics unstable when grappling (tune forces/joint parameters). Grapple doesn't release. Client rope visual incorrect or laggy (check position updates, state sync). Performance impact of grapple physics/raycasts.

STOP & CHECK: Players can fire a grapple gun. Server validates target, applies physics forces using Rapier, and manages active state. Client handles targeting input and renders grapple visuals based on server state.

3.6 Match Flow (Server Instance Control -> Platform Report) (Renumbered from 3.3)

3.6.1 Round timer/countdown system (gameInstance_fps.js):

(MODIFIED) Resetting per-round state needs to happen correctly. Moved the reset logic to prepareNextRound or startRound.

respawnPlayer (called in prepareNextRound) now handles resetting health/shield/ammo/grenades/ability cooldowns.

Need variables for round wins (player1RoundWins, player2RoundWins).

3.6.2 Score tracking (gameInstance_fps.js):

(No major changes needed, kills/deaths tracking remains the same. broadcastGameState includes round wins.)

3.6.3 Victory/defeat conditions (gameInstance_fps.js):

(MODIFIED) Add logic to handle multiple rounds.

Check round win conditions (kills or timer expiry).

Update round win counters (player1RoundWins, player2RoundWins).

Check if match win condition met (ROUNDS_TO_WIN_MATCH).

If match not over, call prepareNextRound (which resets scores/state and calls respawnPlayer for both players) and then start the countdown for the next round.

If match over, proceed to endMatch (escrow, reporting, shutdown).

endMatch payload should include final round scores.

Why: Adapts the match flow to handle multiple rounds, resetting player state (including new features like grenades/abilities/ammo) between rounds, and tracking round wins to determine the overall match winner.

Tip: Clearly define states like round_intermission. Ensure all necessary state is reset in prepareNextRound. Make round/kill limits configurable.

Unit Test: Set low kill/round limits. Play multiple rounds. Verify state resets correctly between rounds (health, shield, ammo, grenades, ability cooldowns, kills/deaths). Verify round win counter updates. Verify match ends correctly after required round wins.

Troubleshooting: State not resetting between rounds. Incorrect round win counting. Match ending prematurely or not ending.

STOP & CHECK: Server instance manages multi-round matches, resets player state correctly between rounds, tracks round wins, determines match winner based on rounds won, and triggers platform interactions.

Phase 4: Platform Integration (FPS Instance)

Objective: Fully implement the FPS game instance's interactions with the broader Solana Gaming Platform (Solana programs, reporting).

4.1 Solana Escrow Interaction: (No direct changes needed based on the new features. The logic for loading authority, initializing Anchor, calling release_escrow, and handling confirmation remains the same.)

4.2 Solana Player Profile Interaction (Optional): (No direct changes needed based on the new features. If implementing update_stats, the W/L update logic remains the same.)

4.3 Final Result Reporting:

4.3.1 Gather Final Data: (MODIFIED) Ensure resultData in endMatch includes final round scores (player1RoundWins, player2RoundWins) alongside kills/deaths. Optionally include stats like average ability usage, grenades hit, etc., if tracked on the server and desired for analytics.

4.3.2 Send MATCH_RESULT: (No changes to mechanism, just payload content).

4.3.3 Implement Graceful Shutdown: (No changes).

Why: The core platform interactions (escrow, reporting) are largely independent of the specific in-game mechanics, but the data reported needs to accurately reflect the outcome of the multi-round match including round scores.

Unit Test: Verify the final MATCH_RESULT payload sent contains the correct round win counts.

Troubleshooting: Incorrect round scores reported.

STOP & CHECK: Platform integration handles escrow/reporting correctly. Final report includes accurate round scores.

Phase 5: Optimization (FPS Instance & Client Component)

Objective: Optimize performance specifically within the FPS game module, considering the impact of new features.

5.1 Network Optimization:

5.1.1 Delta State Compression: (MODIFIED) Ensure the delta compression logic compares and includes changes for all the new fields in PlayerStateFPS: shield, grenades object, ability1CooldownRemaining, weaponSlots, activeWeaponSlot, currentAmmoInClip, grappleState, isReloading, isFlashedUntil, damageAmpActiveUntil, etc. Only send these if they change.

5.1.2 Packet Prioritization: (Analysis remains the same, focus on size/frequency. New messages like THROW_GRENADE_FPS, USE_ABILITY_FPS, FIRE_GRAPPLE_FPS should be considered high priority Client->Server).

5.1.3 Bandwidth Throttling: (Logic remains the same, apply if needed after other optimizations).

5.2 Spatial Optimization:

5.2.1 Utilize Rapier Query Pipeline: (MODIFIED) This is now critical for grenade explosion effects (finding players in radius) and potentially flashbang LoS checks. Grapple gun server validation also uses world.castRay. Ensure these queries use efficient filters.

5.2.2 Interest Management: (Still implicit via 1v1 isolation).

5.2.3 LOD Model Switching (Client): (No changes).

5.3 Instance Resource Optimization:

5.3.1 Profile Node.js Instance: (MODIFIED) Re-profile with new features active (grenade physics/queries, ability effects, grapple physics) to identify new bottlenecks.

5.3.2 Optimize Tick Loop: (MODIFIED) Focus optimization efforts on potentially expensive new logic: grenade detonation queries, frequent grapple force application (if using impulse), ability effect calculations, frequent state change checks for delta compression. Tune Rapier substeps considering grenade/grapple physics stability. Optimize helper functions like applyAbilityEffect, detonateGrenade.

5.3.3 Manage Memory: (MODIFIED) Check for leaks related to grenade timers/state, ability cooldown timers/state, grapple state/joints. Ensure activeGrenades map is cleared properly. Ensure ability cooldown timers are cleared on death/disconnect/match end.

Why: Incorporates the new game mechanics into the optimization process. Delta compression must cover the expanded player state. Server-side queries for grenades/grapples need efficient Rapier usage. Resource profiling must account for the added computational load of these systems.

Tip: Profile extensively with all features enabled. Optimize Rapier queries carefully. Ensure timers/state related to grenades/abilities/grapples are cleaned up robustly to prevent memory leaks.

Unit Test: Verify delta compression works for new state fields. Profile server under load with grenades/abilities/grapples being used frequently; identify and optimize new hotspots. Perform long-running tests with new features to check for memory leaks related to timers/state.

Troubleshooting: Performance degradation due to grenade explosion queries or grapple physics. Delta compression missing new state fields. Memory leaks from uncleared timers or state associated with new features.

STOP & CHECK: Optimization strategies (network delta, spatial queries, resource profiling/tuning, memory management) have been updated to account for the performance characteristics and state complexity of the newly added features (dual weapons, grenades, abilities, grapple).

This completes the integration for Phases 3, 4, and 5. The plan now incorporates dual weapons, reloading, grenades, abilities, and the grapple gun into the combat systems, ensures platform integration handles the multi-round structure, and updates optimization considerations for these new mechanics.


Okay, I have the original plan for Phases 6 and 7. I will now integrate the requested features into these final phases.

Phase 6: Security (FPS Instance & Client Component - with Feature Integrations)

Objective: Implement security measures specific to the FPS game module, focusing on server-authoritative validation of all new game actions (weapon management, grenades, abilities, grapple) and logging relevant events.

6.1 Client Hardening (Platform Responsibility - Passive Benefit)

(No direct changes needed based on the new features. The FPS client component, including logic for new features, benefits passively from platform-level obfuscation, memory tamper detection, and input pattern analysis as implemented in the original plan.)

6.1.1 Code Obfuscation: Verify obfuscation doesn't break new client-side logic (e.g., ability cooldown display, grenade trajectory prediction, grapple visuals).

6.1.2 Memory Tamper Detection: Platform might monitor client variables related to ammo display, grenade counts, ability cooldown UI, but server authority is key.

6.1.3 Input Pattern Analysis: Platform analysis should capture inputs for new actions (weapon switch, reload, grenade keys, ability key, grapple key). Check if heuristics can detect suspicious patterns related to these actions (e.g., instant ability use off cooldown every time, inhumanly fast weapon switching).

STOP & CHECK: Client-side hardening measures provided by the platform are verified to function correctly with the expanded FPS client component logic.

6.2 Server Validation (Within gameInstance_fps.js)

Goal: Implement rigorous authoritative checks for all player actions, including weapon switching, reloading, grenade usage, ability activation, and grappling.

6.2.1 Movement Plausibility Checks (Rapier Validation)

(No fundamental changes needed here, but needs context awareness)

Speed/Teleport/Fly/Noclip checks remain crucial.

NEW Context: These checks must account for movement alterations caused by validated abilities (e.g., Dash ability temporarily increasing velocity) or the grapple gun (applying external forces). Validation logic should temporarily allow higher speeds if the server state confirms the player is actively under the effect of a dash or grapple pull.

// Example Speed Check Modification
const baseMaxSpeed = MAX_PLAYER_SPEED;
let currentAllowedMaxSpeed = baseMaxSpeed;
if (playerState.abilityActive.dash) { // Check if dash effect is active
    currentAllowedMaxSpeed *= 1.5; // Allow higher speed during dash
} else if (playerState.grappleState.active) {
    currentAllowedMaxSpeed *= 2.0; // Allow higher speed while grappling
}
if (rapierBody.linvel().length() > currentAllowedMaxSpeed + speedTolerance) {
    // Reject for Excessive Speed
}


STOP & CHECK: Server movement validation remains robust and now correctly accounts for legitimate speed/position changes caused by validated abilities (Dash) and the grapple gun.

6.2.2 Shot Verification (Lag Comp, LoS, Angle, Rate)

(No fundamental changes needed here. Logic remains the same but incorporates active weapon state for rate/ammo/damage checks as detailed in the modified Phase 3.1.1.)

NEW Context: Server must check for effects modifying damage output (e.g., Damage Amp ability) when calculating final damage in processHit.

// Example Damage Calculation Modification in processHit
let finalDamage = baseDamage * multiplier; // Base damage * hitbox multiplier
const shooterState = players[shooterPlayerId];
if (shooterState && shooterState.damageAmpActiveUntil > Date.now()) {
    finalDamage *= ABILITY_CONFIG_FPS[shooterState.ability1Type].effectValue; // Apply amp
    console.log(`Damage amplified for shooter ${shooterPlayerId}`);
}
// Apply damage using finalDamage...
IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
JavaScript
IGNORE_WHEN_COPYING_END

STOP & CHECK: Shot verification remains multi-layered and authoritative, now also factoring in potential damage modifications from active abilities.

NEW: 6.2.3 Action Validation (Weapons, Grenades, Abilities, Grapple)

Goal: Add specific server-side validation for all the new player actions beyond basic movement and shooting.

Step 1: Weapon Switch Validation (Server Handler SWITCH_WEAPON_FPS):

Check if targetSlot (0 or 1) is valid.

Check if targetSlot is different from playerState.activeWeaponSlot.

Check if player is currently reloading (playerState.isReloading) - typically disallowed.

Check if player is performing another action that prevents switching (e.g., mid-ability use?).

Check for cooldown/delay if weapon switching isn't instant.

Rejection: Log violation, do not change playerState.activeWeaponSlot, potentially send rejection message.

Step 2: Reload Validation (Server Handler RELOAD_WEAPON_FPS):

Check if player is alive and not already reloading.

Check if the active weapon exists (weaponConfig found).

Check if playerState.currentAmmoInClip < weaponConfig.ammoCapacity (cannot reload full weapon).

Check if total ammo reserves allow reloading (if tracking total ammo).

Rejection: Log violation, do not set isReloading flag or start timer.

Step 3: Grenade Throw Validation (Server Handler THROW_GRENADE_FPS):

Check if player is alive.

Check if grenadeType is valid.

Check if playerState.grenades[grenadeType] > 0 (auth count).

Check if player is performing another action preventing throw (reloading?).

Check for cooldown between throws if desired.

Rejection: Log violation, do not decrement grenade count or create physics object.

Step 4: Ability Use Validation (Server Handler USE_ABILITY_FPS):

Check if player is alive.

Check if abilitySlot is valid (e.g., 1).

Check if playerState.ability1CooldownRemaining <= 0 (auth cooldown).

Check if ability type is valid for the character (playerState.ability1Type).

Check if game state allows ability use (e.g., cannot dash while rooted?).

Rejection: Log violation, do not apply effect or start cooldown.

Step 5: Grapple Fire Validation (Server Handler FIRE_GRAPPLE_FPS):

Check if player is alive and not already grappling (!playerState.grappleState.active).

Validate targetPoint received from client (basic sanity check).

Check server-side range (distance < GRAPPLE_MAX_RANGE_SERVER).

Perform server-side raycast to check LoS and valid surface hit near targetPoint.

Check for grapple cooldown if implemented.

Rejection: Log violation, do not set grappleState.active or apply physics.

Step 6: Grapple Release Validation (Server Handler RELEASE_GRAPPLE_FPS):

Check if player is alive and currently grappling (playerState.grappleState.active).

Rejection: Log violation, do not modify grappleState or physics.

Why: Extends server authority to cover all significant gameplay actions introduced. Prevents cheating related to instant reloads, infinite grenades/abilities, instant weapon switches, grappling through walls or out of range, etc. Each action is checked against the authoritative server state before being allowed.

Tip: Place validation checks early in each handler. Log rejections clearly with reasons. Ensure checks cover all relevant state conditions.

Unit Test: For each action (switch, reload, throw nade type, use ability, fire grapple, release grapple): Send valid request -> verify success. Send invalid request (on cooldown, no ammo/grenade, obstructed target, out of range, wrong state) -> verify server logs rejection with correct reason and player state remains unchanged.

Troubleshooting: Legitimate actions rejected (validation logic too strict, state checks incorrect). Cheats bypassing validation (checks missing, logic flawed). Performance impact of complex validation (especially grapple raycast).

STOP & CHECK: Server instance rigorously validates all new game actions (weapon switching, reloading, grenade throws, ability usage, grapple firing/releasing) against authoritative state (ammo, counts, cooldowns, range, LoS, physics), rejecting invalid requests.

6.2.4 Rate Limiting per Action (Instance Level) (Renumbered from 6.2.3)

Step 1: Apply Generic Rate Limiter: (No change) Use generic rate limiter utility.

Step 2: Target FPS Actions: (MODIFIED Include new actions) Apply limits to:

PLAYER_FIRE_FPS (loose limit, real check is fire rate)

SWITCH_WEAPON_FPS (e.g., max 2 per second)

RELOAD_WEAPON_FPS (e.g., max 1 per second)

THROW_GRENADE_FPS (e.g., max 1 per second)

USE_ABILITY_FPS (e.g., max 1 per second)

FIRE_GRAPPLE_FPS (e.g., max 1 per second)

RELEASE_GRAPPLE_FPS (e.g., max 2 per second)

Step 3: Implement Check Early: (No change) Check at start of handler.

Why: Prevents trivial network spamming of the newly added action messages.

Tip: Set limits generously enough not to interfere with normal gameplay, but tight enough to stop simple spam scripts.

Unit Test: Bombard server with each new message type faster than limit. Verify server logs rate limit warnings and ignores excess messages.

Troubleshooting: Limits too strict/loose. Performance impact of rate limiting check itself (should be minimal).

STOP & CHECK: Server instance applies basic rate limiting to handlers for new client actions (switch, reload, grenade, ability, grapple) to prevent simple spam.

6.3 Monitoring & Reporting (Instance -> Platform)

Goal: Ensure the FPS game instance logs security events related to new features and provides relevant data for analysis.

6.3.1 Log Validation Failures (gameInstance_fps.js)

Step 1: Enhance Logging: (MODIFIED Include new rejection reasons) When validation fails (movement, shot, or any new action validation from 6.2.3):

Log event type VALIDATION_REJECT.

Include specific reason: 'Excessive Speed', 'Line of Sight Blocked', 'Invalid Weapon Switch', 'Reload Full Weapon', 'No Grenades Remaining', 'Ability On Cooldown', 'Grapple Target Obstructed', 'Grapple Out Of Range', etc.

Include context: playerId, sequence, details from offending packet (targetSlot, grenadeType, targetPoint, etc.).

Step 2: Structure Logs: (No change) Use structured format (JSON).

Why: Provides detailed, parseable logs of all types of failed actions, giving visibility into potential cheating attempts related to the new game mechanics.

Tip: Use consistent reason codes/strings for easier analysis.

Unit Test: Trigger each new validation failure type from 6.2.3. Verify server logs structured rejection messages with the correct specific reason and context. Check log aggregation system parsing.

Troubleshooting: Logs missing reasons/context. Incorrect reason logged. Format issues.

STOP & CHECK: Server instance logs all failed validation checks, including those for weapon actions, grenades, abilities, and grappling, in a structured format with specific reasons.

6.3.2 Report Tampering Flags (Forwarding) (gameInstance_fps.js)

(No changes needed here. Logic remains the same - instance forwards any client tamper reports to the platform.)

STOP & CHECK: Instance forwards client tamper reports (if any) to the platform.

6.3.3 Provide Data for Analysis (Instance Logging) (gameInstance_fps.js)

Step 1: Log Key Game Events: (MODIFIED Include new events) Log successful key events in structured format:

KILL: (Include killer/victim character IDs, ability used for kill?)

SHOT_FIRED

SHOT_HIT

PLAYER_POSITION

ROUND_END, MATCH_END

NEW Events to Log:

GRENADE_THROWN: Timestamp, matchId, playerId, grenadeType, startPos.

GRENADE_DETONATED: Timestamp, matchId, grenadeType, position, ownerId, playersDamaged/Flashed list (IDs + amount/duration).

ABILITY_USED: Timestamp, matchId, playerId, characterId, abilityType.

GRAPPLE_FIRED: Timestamp, matchId, playerId, targetPoint, actualHitPoint, distance.

GRAPPLE_RELEASED: Timestamp, matchId, playerId, durationHeld.

Step 2: Consistent Formatting: (No change) Use JSON.

Why: Provides the raw data feed for the platform's statistical analysis to understand usage patterns and effectiveness of grenades, abilities, and grappling, potentially identifying anomalies or informing balance decisions, in addition to basic combat stats.

Tip: Log context relevant for analysis (e.g., did an ability use lead to a kill shortly after?). Be mindful of log volume for frequent events like grapple firing.

Unit Test: Play through match using new features. Check server logs; verify structured log entries exist for grenade throws/detonations, ability uses, grapple fires/releases with correct context. Check log aggregation system.

Troubleshooting: Events not logged. Incorrect/missing data in logs. Excessive log volume from new events.

STOP & CHECK: Server instance logs key successful gameplay events, including those related to grenades, abilities, and grappling, in a structured format for platform analysis.

Phase 7: Polish & Launch Prep (FPS Module - with Feature Integrations)

Objective: Finalize the FPS game module, ensuring performance with new features, integrating progression hooks for new actions, conducting comprehensive E2E testing including new mechanics, and refining balance considering characters, abilities, grenades, and grapple.

7.1 Performance Tuning (FPS Specific)

Goal: Achieve target performance considering the added load of new game mechanics.

7.1.1 Client FPS Optimization (GameViewFPS.jsx):

(MODIFIED) Profiling/Tuning must focus on:

Rendering costs of different map visuals (map1.glb vs map2.glb vs map3.glb).

Performance impact of rendering multiple grenade projectiles/explosions simultaneously.

Cost of ability visual effects (dash trails, heal auras, etc.).

Cost of rendering grapple rope/hook visuals.

CPU cost of client-side prediction for grenades/grapple if implemented.

Graphics settings should potentially affect complexity/number of particle effects for explosions/abilities.

STOP & CHECK: Client performance optimized considering visual load of different maps, grenades, abilities, and grapple effects. Graphics settings appropriately adjust these elements.

7.1.2 Server Tick Rate Calibration (gameInstance_fps.js):

(MODIFIED) Load testing must simulate active use of:

Grenade throwing and physics simulation (multiple active grenades).

Grenade detonation queries (intersectionsWithShape, raycasts).

Ability usage and effect application (physics impulses, state checks).

Grapple gun usage (server validation raycasts, physics application - joints/impulses).

Verify tick rate stability under the combined load of core movement/shooting plus the new systems. Final tuning may involve optimizing grenade queries, grapple physics, or ability logic identified as bottlenecks.

STOP & CHECK: Server tick rate remains stable under sustained load including frequent use of grenades, abilities, and grappling, ensuring responsive authoritative simulation of all mechanics.

7.1.3 Database Indexing (N/A for Instance): (No change)

7.2 Progression Integration Hooks

Goal: Ensure new gameplay actions correctly contribute to platform progression (Stats, Achievements).

7.2.1 Report Stats Reliably (gameInstance_fps.js -> Platform API):

(MODIFIED) Final MATCH_RESULT payload could optionally include aggregated stats related to new features if desired for player profiles (though often kept for backend analysis only):

grenadesHitCount, abilityUsedCount, grappleAttachCount.

Average stats per round?

Primary reporting of W/L, K/D based on final outcome remains essential.

STOP & CHECK: Final match report includes core outcome data. Optional: Add aggregated stats for new mechanics if needed for persistent profiles. Platform backend processes reported data correctly.

7.2.2 Trigger Achievement Events (gameInstance_fps.js -> Platform Logs/API):

(MODIFIED) Identify achievements related to new features:

"Get a kill with a Frag Grenade"

"Stick an opponent with a Semtex"

"Flash 2 opponents with one Flashbang" (requires tracking effects)

"Get a kill while Damage Amp is active"

"Travel X distance with the Grapple Gun in one match"

"Get Y kills shortly after using Dash"

Ensure corresponding events (GRENADE_DETONATED with damage context, ABILITY_USED, GRAPPLE_FIRED with distance, KILL with context flags) are logged/reported with sufficient detail for the platform achievement system to process.

STOP & CHECK: Server logs/reports specific events related to grenades, abilities, and grappling with sufficient context for the platform achievement system to track progress.

7.3 Integration Testing & Refinement

Goal: Verify seamless operation including new features and refine balance considering the expanded gameplay mechanics.

7.3.1 Test Full E2E Loop (FPS Focus):

(MODIFIED) E2E test plan must now include steps covering:

Character Selection: Player A chooses Char A, Player B chooses Char B before matchmaking/escrow.

Map Variation: Run tests on different maps specified by mapId.

Gameplay Actions: During the match phase, specifically test:

Switching weapons, reloading.

Throwing each type of grenade, observing physics/effects.

Using character-specific abilities, observing effects/cooldowns.

Using the grapple gun, observing movement/visuals.

Outcome Verification: Verify health/shield reflects character choice, damage calculation includes ability effects, stats reported include round wins.

STOP & CHECK: Full E2E flow tested successfully, including character selection, map variations, and usage of all new gameplay mechanics (weapons, grenades, abilities, grapple), with correct state changes and reporting verified.

7.3.2 Test Instance Lifecycle (FPS Specific):

(No major changes needed, but ensure tests use instances configured with different maps/character setups to catch potential lifecycle issues specific to certain configurations.)

STOP & CHECK: Instance lifecycle management works reliably for instances configured with different maps and character loadouts.

7.3.3 Refine Game Balance & Feel (FPS Tuning):

(MODIFIED) This step becomes significantly more complex and crucial. Playtesting and feedback need to focus on:

Character Balance: Are the different base health/shield values fair? Are the abilities balanced against each other (cooldowns, impact)? Does any character feel significantly stronger/weaker?

Weapon Balance: Re-evaluate weapon TTK considering different character health/shields.

Grenade Balance: Are grenades too strong/weak? Is fuse timing right? Is flashbang duration fair? Is usage limit (1 each per round) appropriate?

Ability Balance: Cooldowns, durations, effect magnitudes - do they provide meaningful impact without being overpowered? Do they synergize/clash in interesting ways?

Grapple Balance: Range, speed, cooldown (if any) - does it feel useful but not exploitable? Does it trivialize map traversal or positioning?

Map Balance: Do different maps favor certain characters/abilities/weapons? Are spawn points fair across maps? Does grapple gun break map flow?

Overall Pacing: How do abilities, grenades, and grapple affect the flow and pacing of a 1v1 duel compared to just shooting/movement?

Iteratively tune: CHARACTER_CONFIG_FPS (stats), ABILITY_CONFIG_FPS (cooldowns, effects), GRENADE_CONFIG_FPS (damage, radius, fuse), WEAPON_CONFIG_FPS, grapple parameters (range, speed), map layouts/spawn points for map1, map2, map3 based on feedback.

STOP & CHECK: Comprehensive playtesting and iterative tuning have been performed to balance character stats/abilities, grenades, grapple mechanics, and weapon performance across different maps, resulting in a fair and engaging 1v1 experience.

This completes the integration for Phases 6 and 7. The plan now includes server validation for all new actions, logging relevant for security analysis, performance tuning considering the new features, hooks for progression systems based on new mechanics, and critically, a comprehensive E2E testing and balance refinement process incorporating character differences, maps, abilities, grenades, and the grapple gun. The FPS module is now fully specified with all requested features integrated across all phases.



